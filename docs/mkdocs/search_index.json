{
    "docs": [
        {
            "location": "/", 
            "text": "LARA Interactive API\n\n\nTable of contents:\n\n\n\n\n\n\nLARA Interactive API\n\n\nStartup and Initialization\n\n\niframe-saver.coffee Messages\n\n\ngetExtendedSupport\n\n\nextendedSupport\n\n\ngetLearnerUrl\n\n\nsetLearnerUrl\n\n\ngetInteractiveState\n\n\ninteractiveState\n\n\ngetAuthInfo\n\n\nauthInfo\n\n\nloadInteractive\n\n\ninitInteractive\n\n\n\n\n\n\nglobal-iframe-saver.coffee Messages\n\n\ninteractiveStateGlobal\n\n\nloadInteractiveGlobal\n\n\n\n\n\n\nlogger.js Messages\n\n\nlog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStartup and Initialization\n\n\nLARA interactive iframes communicate by using \niFramePhone\n through three scripts loaded by the server in the browser:  \niframe-saver.coffee\n,\n\nglobal-iframe-saver.coffee\n and\n\nlogger.js\n.  The LARA logging service also uses iFramePhones \nRPC endpoint\n to log events from the interactives.\n\n\nThe iframe-saver.coffee script first listens for the iFramePhone to connect and registers the message handlers documented below, then sends separate \ngetExtendedSupport\n and \ngetLearnerUrl\n\nrequests to the client and finally calls back to the LARA server to get the current interactive state.  If there is existing interactive state the client will receive a \nloadInteractive\n message with the current interactive state as the parameter to the message.  However if no previous interactive state is found on the server the client will \nnot\n receive a callback.  To allow interactives to have a\nconsistent startup a new message was added, \ninitInteractive\n (documented below), which is always sent to the client after the server is queried for the interactive state by iframe-saver.coffee.\n\n\nThe global-iframe-saver.coffee script sets up a listener for the \ninteractiveStateGlobal\n message and sends one message: \nloadInteractiveGlobal\n.\n\n\nThe logger.js sets up a listener for the \nlog\n message.\n\n\nSince the three scripts above and the interactive's code are both running in the browser we will use the term server to mean the code in scripts interfacing with LARA above and client to be the interactive.\n\n\niframe-saver.coffee Messages\n\n\nThe client-side API can be split into two parts: messages initiated by the server to inform the client or request data back from the client and those initiated by the client to inform the server or request data back from the server.  Some of the messages from the client can be both responses to the server when it queries for information and requests to the server to set that information.\n\n\ngetExtendedSupport\n\n\nSent automatically by the server at startup to query the client about their \nextendedSupport\n status.  This is the first message the client will receive and is sent before the call is made to\nthe server to get the interactive state.  It has no payload data.\n\n\nextendedSupport\n\n\nCan be thought of as \nsetExtendedSupport\n. Sent by the client either in response to receiving a \ngetExtendedSupport\n message or can be initiated by the client.  The payload for the message is an object with the following structure: \n{reset: \nboolean\n}\n.  If \nreset\n is true, we will allow the user to 'reset' the interactive via the \ndelete\n button in the LARA runtime.\n\n\ngetLearnerUrl\n\n\nSent automatically by the server at startup to query the client about their learner url (the client responds via \nsetLearnerUrl\n).  This is the second message the client will receive and is sent before the call is made to the server to get the interactive state.  It has no payload data.\n\n\nsetLearnerUrl\n\n\nSent by the client either in response to receiving a \ngetLearnerUrl\n message or can be initiated by the client. The payload for the message is the string that denotes exact URL for the current student.\n\n\ngetInteractiveState\n\n\nSent automatically by the server every 5 seconds to query the client about their interactive state. It has no payload data.\n\n\ninteractiveState\n\n\nCan be thought of as \nsetInteractiveState\n. Sent by the client either in response to receiving a \ngetInteractiveState\n message or can be initiated by the client.  The payload for the message is an arbitrary serializable object that will be stored by the LARA server.\n\n\ngetAuthInfo\n\n\nSent by the client to the server to request the current users authentication information.  It has no payload data.\n\n\nauthInfo\n\n\nSent by the server only in response to a \ngetAuthInfo\n request by the client.  The payload is the object \n{provider: \nstring\n, loggedIn: \nboolean\n, email: \nstring\n}\n where \nprovider\n and \nloggedIn\n\nare always set and \nemail\n is only set if the user has an email address.\n\n\nloadInteractive\n\n\nSent by the server at startup after the LARA server is queried about the interactive's state and \nonly\n if the interactive has state.  The payload for the message is a arbitrary serialized object\npreviously set by the \ninteractiveState\n message.\n\n\ninitInteractive\n\n\nSent by the server at startup after the LARA server is queried about the interactive's state.  This message will always be sent, even if there is an error querying the server about the interactive state.\nThe payload is the object:\n\n\n{version: 1, error: \nstring\n, interactiveState: \nobject\n, hasLinkedState: \nboolean\n, linkedState: \nobject\n}\n\n\nThe \nerror\n member will be a string denoting any error querying the server about the interactive state or will be null otherwise.  The \ninteractiveState\n member will be null if there is no current state or will otherwise be the same object returned by \nloadInteractive\n.  The \nhasLinkedState\n member will be true if the interactive is linked to another interactive in the authoring system and the \nlinkedState\n will be the current interactive state of that linked interactive.  Linked interactives are currently in development.\n\n\nglobal-iframe-saver.coffee Messages\n\n\ninteractiveStateGlobal\n\n\nSent by the client to the server and sets the global state that should be shared with all the interactives embedded in the current activity for the current student.  The payload for the message is\nan arbitrary serializable object. The global state is saved in database as text (stringified JSON) and LARA does not care about its content.\n\n\nOnce this message is received, the server immediately posts \nloadInteractiveGlobal\n to all interactives on the same page (except from the sender of the original save message).\n\n\nloadInteractiveGlobal\n\n\nSent by the server to all interactives on the current page (for current activity and student).  The payload for the message is an arbitrary serialized object.  It's interactive responsibility to interpret this message and load (or not) the given state.\n\n\nThis message is sent by the server when:\n\n\n\n\nThe \ninteractiveStateGlobal\n message is received by the server\n\n\nThe activity page is loaded \nand\n the global interactive state is available in LARA activity run (so only if \ninteractiveStateGlobal\n has been received earlier)\n\n\n\n\nlogger.js Messages\n\n\nlog\n\n\nThis message proxies communication from the interactive \u2192 LARA \u2192 Logging server.  There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone:\n\n\nphone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2})\n\n\n\n\nLARA listens to these events only when logging is enabled (they will be ignored otherwise). When a \nlog\n message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).", 
            "title": "LARA Interactive API"
        }, 
        {
            "location": "/#lara-interactive-api", 
            "text": "Table of contents:    LARA Interactive API  Startup and Initialization  iframe-saver.coffee Messages  getExtendedSupport  extendedSupport  getLearnerUrl  setLearnerUrl  getInteractiveState  interactiveState  getAuthInfo  authInfo  loadInteractive  initInteractive    global-iframe-saver.coffee Messages  interactiveStateGlobal  loadInteractiveGlobal    logger.js Messages  log", 
            "title": "LARA Interactive API"
        }, 
        {
            "location": "/#startup-and-initialization", 
            "text": "LARA interactive iframes communicate by using  iFramePhone  through three scripts loaded by the server in the browser:   iframe-saver.coffee , global-iframe-saver.coffee  and logger.js .  The LARA logging service also uses iFramePhones  RPC endpoint  to log events from the interactives.  The iframe-saver.coffee script first listens for the iFramePhone to connect and registers the message handlers documented below, then sends separate  getExtendedSupport  and  getLearnerUrl \nrequests to the client and finally calls back to the LARA server to get the current interactive state.  If there is existing interactive state the client will receive a  loadInteractive  message with the current interactive state as the parameter to the message.  However if no previous interactive state is found on the server the client will  not  receive a callback.  To allow interactives to have a\nconsistent startup a new message was added,  initInteractive  (documented below), which is always sent to the client after the server is queried for the interactive state by iframe-saver.coffee.  The global-iframe-saver.coffee script sets up a listener for the  interactiveStateGlobal  message and sends one message:  loadInteractiveGlobal .  The logger.js sets up a listener for the  log  message.  Since the three scripts above and the interactive's code are both running in the browser we will use the term server to mean the code in scripts interfacing with LARA above and client to be the interactive.", 
            "title": "Startup and Initialization"
        }, 
        {
            "location": "/#iframe-savercoffee-messages", 
            "text": "The client-side API can be split into two parts: messages initiated by the server to inform the client or request data back from the client and those initiated by the client to inform the server or request data back from the server.  Some of the messages from the client can be both responses to the server when it queries for information and requests to the server to set that information.", 
            "title": "iframe-saver.coffee Messages"
        }, 
        {
            "location": "/#getextendedsupport", 
            "text": "Sent automatically by the server at startup to query the client about their  extendedSupport  status.  This is the first message the client will receive and is sent before the call is made to\nthe server to get the interactive state.  It has no payload data.", 
            "title": "getExtendedSupport"
        }, 
        {
            "location": "/#extendedsupport", 
            "text": "Can be thought of as  setExtendedSupport . Sent by the client either in response to receiving a  getExtendedSupport  message or can be initiated by the client.  The payload for the message is an object with the following structure:  {reset:  boolean } .  If  reset  is true, we will allow the user to 'reset' the interactive via the  delete  button in the LARA runtime.", 
            "title": "extendedSupport"
        }, 
        {
            "location": "/#getlearnerurl", 
            "text": "Sent automatically by the server at startup to query the client about their learner url (the client responds via  setLearnerUrl ).  This is the second message the client will receive and is sent before the call is made to the server to get the interactive state.  It has no payload data.", 
            "title": "getLearnerUrl"
        }, 
        {
            "location": "/#setlearnerurl", 
            "text": "Sent by the client either in response to receiving a  getLearnerUrl  message or can be initiated by the client. The payload for the message is the string that denotes exact URL for the current student.", 
            "title": "setLearnerUrl"
        }, 
        {
            "location": "/#getinteractivestate", 
            "text": "Sent automatically by the server every 5 seconds to query the client about their interactive state. It has no payload data.", 
            "title": "getInteractiveState"
        }, 
        {
            "location": "/#interactivestate", 
            "text": "Can be thought of as  setInteractiveState . Sent by the client either in response to receiving a  getInteractiveState  message or can be initiated by the client.  The payload for the message is an arbitrary serializable object that will be stored by the LARA server.", 
            "title": "interactiveState"
        }, 
        {
            "location": "/#getauthinfo", 
            "text": "Sent by the client to the server to request the current users authentication information.  It has no payload data.", 
            "title": "getAuthInfo"
        }, 
        {
            "location": "/#authinfo", 
            "text": "Sent by the server only in response to a  getAuthInfo  request by the client.  The payload is the object  {provider:  string , loggedIn:  boolean , email:  string }  where  provider  and  loggedIn \nare always set and  email  is only set if the user has an email address.", 
            "title": "authInfo"
        }, 
        {
            "location": "/#loadinteractive", 
            "text": "Sent by the server at startup after the LARA server is queried about the interactive's state and  only  if the interactive has state.  The payload for the message is a arbitrary serialized object\npreviously set by the  interactiveState  message.", 
            "title": "loadInteractive"
        }, 
        {
            "location": "/#initinteractive", 
            "text": "Sent by the server at startup after the LARA server is queried about the interactive's state.  This message will always be sent, even if there is an error querying the server about the interactive state.\nThe payload is the object:  {version: 1, error:  string , interactiveState:  object , hasLinkedState:  boolean , linkedState:  object }  The  error  member will be a string denoting any error querying the server about the interactive state or will be null otherwise.  The  interactiveState  member will be null if there is no current state or will otherwise be the same object returned by  loadInteractive .  The  hasLinkedState  member will be true if the interactive is linked to another interactive in the authoring system and the  linkedState  will be the current interactive state of that linked interactive.  Linked interactives are currently in development.", 
            "title": "initInteractive"
        }, 
        {
            "location": "/#global-iframe-savercoffee-messages", 
            "text": "", 
            "title": "global-iframe-saver.coffee Messages"
        }, 
        {
            "location": "/#interactivestateglobal", 
            "text": "Sent by the client to the server and sets the global state that should be shared with all the interactives embedded in the current activity for the current student.  The payload for the message is\nan arbitrary serializable object. The global state is saved in database as text (stringified JSON) and LARA does not care about its content.  Once this message is received, the server immediately posts  loadInteractiveGlobal  to all interactives on the same page (except from the sender of the original save message).", 
            "title": "interactiveStateGlobal"
        }, 
        {
            "location": "/#loadinteractiveglobal", 
            "text": "Sent by the server to all interactives on the current page (for current activity and student).  The payload for the message is an arbitrary serialized object.  It's interactive responsibility to interpret this message and load (or not) the given state.  This message is sent by the server when:   The  interactiveStateGlobal  message is received by the server  The activity page is loaded  and  the global interactive state is available in LARA activity run (so only if  interactiveStateGlobal  has been received earlier)", 
            "title": "loadInteractiveGlobal"
        }, 
        {
            "location": "/#loggerjs-messages", 
            "text": "", 
            "title": "logger.js Messages"
        }, 
        {
            "location": "/#log", 
            "text": "This message proxies communication from the interactive \u2192 LARA \u2192 Logging server.  There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone:  phone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2})  LARA listens to these events only when logging is enabled (they will be ignored otherwise). When a  log  message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).", 
            "title": "log"
        }, 
        {
            "location": "/shutterbug/", 
            "text": "Shutterbug API\n\n\nShutterbug\n is used widely in Lab and in LARA, it uses \npostMessage\n to request child iFrames HTML content for snapshotting.\n\n\nThe basic PostMessage API Calls that are used in the shutterbug javascript project are \ndocumented in the github repo\n\n\nShutterbug Messages\n\n\nhtmlFragRequest\n\n\nParent asks iframes about their content:\n\n\n var message  = {\n   type:        'htmlFragRequest',\n   id:          id,       // Shutterbug ID\n   iframeReqId: iframeId, // position of iframe in dom\n   iframeReqTimeout: this.iframeReqTimeout * 0.6\n };\n window.postMessage(JSON.stringify(message), \n*\n);\n\n\n\n\nAnd an Iframe sends its content back:\n\n\nvar response = {\n  type:        'htmlFragResponse',\n  value:       html,\n  iframeReqId: iframeReqId, // counter, from request\n  id:          id           // sender_id from request\n};\nsource.postMessage(JSON.stringify(response), \n*\n);", 
            "title": "Shutterbug API"
        }, 
        {
            "location": "/shutterbug/#shutterbug-api", 
            "text": "Shutterbug  is used widely in Lab and in LARA, it uses  postMessage  to request child iFrames HTML content for snapshotting.  The basic PostMessage API Calls that are used in the shutterbug javascript project are  documented in the github repo", 
            "title": "Shutterbug API"
        }, 
        {
            "location": "/shutterbug/#shutterbug-messages", 
            "text": "", 
            "title": "Shutterbug Messages"
        }, 
        {
            "location": "/shutterbug/#htmlfragrequest", 
            "text": "Parent asks iframes about their content:   var message  = {\n   type:        'htmlFragRequest',\n   id:          id,       // Shutterbug ID\n   iframeReqId: iframeId, // position of iframe in dom\n   iframeReqTimeout: this.iframeReqTimeout * 0.6\n };\n window.postMessage(JSON.stringify(message),  * );  And an Iframe sends its content back:  var response = {\n  type:        'htmlFragResponse',\n  value:       html,\n  iframeReqId: iframeReqId, // counter, from request\n  id:          id           // sender_id from request\n};\nsource.postMessage(JSON.stringify(response),  * );", 
            "title": "htmlFragRequest"
        }, 
        {
            "location": "/using-iframe-phone/", 
            "text": "Using iFramePhone\n\n\nAs mentioned \niFramePhone\n is the service which LARA uses for much of its iFrame communication.   It is also used by Lab Interactives internally. Most of the Lab messages are ignored by LARA.\n\n\nHere for reference is what the implementation looks like. Taken from the \niFramePhone Readme\n:\n\n\nParent Setup\n\n\nvar phone = new iframePhone.ParentEndpoint(iframeElement, function () {\n  console.log(\nconnection with iframe established\n);\n});\nphone.post('testMessage', 'abc');\nphone.addListener('response', function (content) {\n  console.log(\nparent received response: \n + content);\n});\n\n\n\n\nIframe (child) Setup\n\n\nvar phone = iframePhone.getIFrameEndpoint();\nphone.addListener('testMessage', function (content) {\n  console.log(\niframe received message: \n + content);\n  phone.post('response', 'got it');\n});\n// IMPORTANT:\n// Initialize connection after all message listeners are added!\nphone.initialize();\n\n\n\n\nHello Messages\n\n\niFramePhone uses a \nhello\n messages to start communication with a specified origin. These messages get sent using the PostMessage API and look like this:\n\n\nvar message = {\n  type: \nhello\n,\n  origin: \nhttps://lab.concord.org\n\n};\n\n\n\n\nOther Messages\n\n\nSubsequent messages follow a similar pattern, specifiying \ntype\n which helps determine which listeners to notify:\n\n\nvar message = {\n  type:\nmodelLoaded\n,\n  \u2026\n};\n\n\n\n\nMessage Posting Implementation\n\n\nThe post messages looks like this as they are being sent out through iFramePhone. You don't need to worry about this; it is here for reference.\n\n\nmessage = {\n  type: \ngetLearnerUrl\n,\n  origin: \nhttp://localhost:3000\n,\n  content: {} // something specific to 'type'\n};\nWindow.postMessage(JSON.stringify(message), targetOrigin);", 
            "title": "Using iFramePhone"
        }, 
        {
            "location": "/using-iframe-phone/#using-iframephone", 
            "text": "As mentioned  iFramePhone  is the service which LARA uses for much of its iFrame communication.   It is also used by Lab Interactives internally. Most of the Lab messages are ignored by LARA.  Here for reference is what the implementation looks like. Taken from the  iFramePhone Readme :", 
            "title": "Using iFramePhone"
        }, 
        {
            "location": "/using-iframe-phone/#parent-setup", 
            "text": "var phone = new iframePhone.ParentEndpoint(iframeElement, function () {\n  console.log( connection with iframe established );\n});\nphone.post('testMessage', 'abc');\nphone.addListener('response', function (content) {\n  console.log( parent received response:   + content);\n});", 
            "title": "Parent Setup"
        }, 
        {
            "location": "/using-iframe-phone/#iframe-child-setup", 
            "text": "var phone = iframePhone.getIFrameEndpoint();\nphone.addListener('testMessage', function (content) {\n  console.log( iframe received message:   + content);\n  phone.post('response', 'got it');\n});\n// IMPORTANT:\n// Initialize connection after all message listeners are added!\nphone.initialize();", 
            "title": "Iframe (child) Setup"
        }, 
        {
            "location": "/using-iframe-phone/#hello-messages", 
            "text": "iFramePhone uses a  hello  messages to start communication with a specified origin. These messages get sent using the PostMessage API and look like this:  var message = {\n  type:  hello ,\n  origin:  https://lab.concord.org \n};", 
            "title": "Hello Messages"
        }, 
        {
            "location": "/using-iframe-phone/#other-messages", 
            "text": "Subsequent messages follow a similar pattern, specifiying  type  which helps determine which listeners to notify:  var message = {\n  type: modelLoaded ,\n  \u2026\n};", 
            "title": "Other Messages"
        }, 
        {
            "location": "/using-iframe-phone/#message-posting-implementation", 
            "text": "The post messages looks like this as they are being sent out through iFramePhone. You don't need to worry about this; it is here for reference.  message = {\n  type:  getLearnerUrl ,\n  origin:  http://localhost:3000 ,\n  content: {} // something specific to 'type'\n};\nWindow.postMessage(JSON.stringify(message), targetOrigin);", 
            "title": "Message Posting Implementation"
        }, 
        {
            "location": "/safari-cookies-redirects/", 
            "text": "Safari / IE, cookies and iframe redirects\n\n\nWhile recently debugging a weird authentication failure in an app that is regularly embedded within an iframe, I discovered some unexpected behavior in Safari and IE with respect to how it handles cookies for the sites within the iframe.\n\n\nThe TL;DR is this: \nCookies will not be sent to the destination site of a 302 redirect\n (the destination defined in the HTTP Location header), regardless of whether or not you've previously visited that site (unless the site is within the same main domain as the redirecting site).\n\n\nIn Safari, most of this behavior is due to the recent change of default settings. Under \nPrivacy\n -\n \nCookies and website data\n, the setting changed from \nAllow from websites I visit\n to \nAllow from current website only\n.\n\n\nThere doesn't seem to be a setting around this behavior in IE.\n\n\nExample\n\n\nOur app uses OAuth2 to sign in via a different app. The sign in process involves several redirects (these aren't the actual domains/paths, but roughly the same steps):\n\n\nRequest                            Response\nGET:  https://app.com/login        302: https://sso.com/sso/login\nGET:  https://sso.com/sso/login    200\nPOST: https://sso.com/sso/login    302: https://app.com/sso/callback\nGET:  https://app.com/sso/callback 302: https://app.com/\n\n\n\nThis all works fine in Safari when accessing app.com in a top-level window. However, this all breaks down when running within an iframe.\n\n\nIt turns out that Safari will \nnot\n send cookies to \nsso.com\n in the 2nd request, and additionally will \nnot\n send cookies to \napp.com\n in the 4th request. The whole sign in process relies on maintaining consistent sessions, so when no cookies are sent, the sign in doesn't take, and the user is left on app.com in a logged out state.\n\n\nWorkarounds\n\n\n\n\n\n\nI haven't been able to test this, but supposedly you can work around this cookie behavior by rendering a page which redirects via the page content, rather than redirecting via a 302 response with a \nLocation\n header.\n\n\nhtml\n\n  \nhead\n\n    \ntitle\nSign In\n/title\n\n    \nmeta http-equiv=\"refresh\" content=\"0;URL='https://sso.com/sso/login'\" /\n\n  \n/head\n\n  \nbody\n\n    \np\nThis page has moved to a \na href=\"https://sso.com/sso/login\"\nnew location\n/a\n.\n/p\n\n  \n/body\n\n\n/html\n\n\n\n\nHowever, you'll have to take care that the request to the other site is essentially the same (Referrer, Origin, etc all present the same info).\n\n\n\n\n\n\nAlso, Safari's definition of \ncurrent website\n is a bit loose when it comes to the hostname. foo.app.com is considered the same site as bar.app.com. We were fortunate enough to be able to use this tactic to bring our app into the same \"site\" as the sso provider, but that's not usually possible when working with a 3rd-party provider.\n\n\n\n\n\n\nIf your redirecting code makes a full round-trip, another option is to do all of your redirecting in a separate window. Use Javascript to open a window, and then monitor its url. Once the url is back to the location you're expecting, close the window and reload the iframe page.\n\n\nThe library is here:\n\n\n// A wrapper around having an external link pop up in its own window, and then automatically monitoring it\n// and closing it when it returns to the same domain as the current page.\n\nwindow.inIframe = function() {\n  try {\n      return window.self !== window.top;\n  } catch (e) {\n      return true;\n  }\n};\n\nwindow.AutomaticallyClosingPopupLink = {\n  configure: function($link, directUrl, popupUrl, afterCloseUrl) {\n    var onClick = function() {\n      if (window.inIframe()) {\n        // Pop up the url in a new window\n        // Monitor it and close it when done\n        // Redirect the current page when closed\n        this._popupWindow($link.id, popupUrl, afterCloseUrl);\n      } else {\n        window.location.href = directUrl;\n      }\n    }.bind(this);\n    $link.on('click', onClick);\n  },\n\n  // This code was adapted from CODAP's implementation of a similar feature\n  _popupWindow: function(id, popupUrl, afterCloseUrl) {\n    var width  = 800,\n        height = 480,\n        position = this._computeScreenLocation(width, height),\n        windowFeatures = [\n          'width=' + width,\n          'height=' + height,\n          'top=' + position.top || 200,\n          'left=' + position.left || 200,\n          'dependent=yes',\n          'resizable=no',\n          'location=no',\n          'dialog=yes',\n          'menubar=no'\n        ],\n        exceptionCount = 0,\n        panel = window.open(popupUrl, id, windowFeatures.join()),\n        checkPanelHref = function() {\n          try {\n            /* This is a bit of a hack. Accessing a popup's location throws a security exception\n             * when the url is cross-origin. Therefore, 1) this should only be used with urls that are         cross-origin, and 2) the url\n             * should eventually return to a non-cross-origin url at the time the window should be closed.\n             */\n            var href = panel.location.href; // This will throw an exception if the url is still cross-origin.\n\n            // If exceptionCount is not 0, then we hit an external url and came back. Assume that we're done.\n            // If it's still 0, then keep waiting for the url to change to something external and change back.\n            if (exceptionCount \n 0) {\n              window.clearInterval(timer);\n              panel.close();\n              if (afterCloseUrl) {\n                document.location = afterCloseUrl;\n              } else {\n                document.location.reload();\n              }\n            }\n          } catch(e) {\n            exceptionCount++;\n          }\n        },\n        timer = window.setInterval(checkPanelHref, 200);\n  },\n\n  _computeScreenLocation: function(w, h) {\n    // Fixes dual-screen position                         Most browsers      Firefox\n    var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;\n    var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;\n\n    var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ?         document.documentElement.clientWidth : screen.width;\n    var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\n    var left = ((width / 2) - (w / 2)) + dualScreenLeft;\n    var top = ((height / 2) - (h / 2)) + dualScreenTop;\n    return {left: left, top: top};\n  }\n};\n\n\n\nAnd it's used via this code in the page:\n\n\njQuery(function() {\n  var button = jQuery('#login_button'),\n      path = '/login',\n      popup = '/popupLogin',\n      redirect = '/';\n\n  window.AutomaticallyClosingPopupLink.configure(button, path, popup, redirect);\n});", 
            "title": "Safari / IE, cookies and iframe redirects"
        }, 
        {
            "location": "/safari-cookies-redirects/#safari-ie-cookies-and-iframe-redirects", 
            "text": "While recently debugging a weird authentication failure in an app that is regularly embedded within an iframe, I discovered some unexpected behavior in Safari and IE with respect to how it handles cookies for the sites within the iframe.  The TL;DR is this:  Cookies will not be sent to the destination site of a 302 redirect  (the destination defined in the HTTP Location header), regardless of whether or not you've previously visited that site (unless the site is within the same main domain as the redirecting site).  In Safari, most of this behavior is due to the recent change of default settings. Under  Privacy  -   Cookies and website data , the setting changed from  Allow from websites I visit  to  Allow from current website only .  There doesn't seem to be a setting around this behavior in IE.", 
            "title": "Safari / IE, cookies and iframe redirects"
        }, 
        {
            "location": "/safari-cookies-redirects/#example", 
            "text": "Our app uses OAuth2 to sign in via a different app. The sign in process involves several redirects (these aren't the actual domains/paths, but roughly the same steps):  Request                            Response\nGET:  https://app.com/login        302: https://sso.com/sso/login\nGET:  https://sso.com/sso/login    200\nPOST: https://sso.com/sso/login    302: https://app.com/sso/callback\nGET:  https://app.com/sso/callback 302: https://app.com/  This all works fine in Safari when accessing app.com in a top-level window. However, this all breaks down when running within an iframe.  It turns out that Safari will  not  send cookies to  sso.com  in the 2nd request, and additionally will  not  send cookies to  app.com  in the 4th request. The whole sign in process relies on maintaining consistent sessions, so when no cookies are sent, the sign in doesn't take, and the user is left on app.com in a logged out state.", 
            "title": "Example"
        }, 
        {
            "location": "/safari-cookies-redirects/#workarounds", 
            "text": "I haven't been able to test this, but supposedly you can work around this cookie behavior by rendering a page which redirects via the page content, rather than redirecting via a 302 response with a  Location  header.  html \n   head \n     title Sign In /title \n     meta http-equiv=\"refresh\" content=\"0;URL='https://sso.com/sso/login'\" / \n   /head \n   body \n     p This page has moved to a  a href=\"https://sso.com/sso/login\" new location /a . /p \n   /body  /html   However, you'll have to take care that the request to the other site is essentially the same (Referrer, Origin, etc all present the same info).    Also, Safari's definition of  current website  is a bit loose when it comes to the hostname. foo.app.com is considered the same site as bar.app.com. We were fortunate enough to be able to use this tactic to bring our app into the same \"site\" as the sso provider, but that's not usually possible when working with a 3rd-party provider.    If your redirecting code makes a full round-trip, another option is to do all of your redirecting in a separate window. Use Javascript to open a window, and then monitor its url. Once the url is back to the location you're expecting, close the window and reload the iframe page.  The library is here:  // A wrapper around having an external link pop up in its own window, and then automatically monitoring it\n// and closing it when it returns to the same domain as the current page.\n\nwindow.inIframe = function() {\n  try {\n      return window.self !== window.top;\n  } catch (e) {\n      return true;\n  }\n};\n\nwindow.AutomaticallyClosingPopupLink = {\n  configure: function($link, directUrl, popupUrl, afterCloseUrl) {\n    var onClick = function() {\n      if (window.inIframe()) {\n        // Pop up the url in a new window\n        // Monitor it and close it when done\n        // Redirect the current page when closed\n        this._popupWindow($link.id, popupUrl, afterCloseUrl);\n      } else {\n        window.location.href = directUrl;\n      }\n    }.bind(this);\n    $link.on('click', onClick);\n  },\n\n  // This code was adapted from CODAP's implementation of a similar feature\n  _popupWindow: function(id, popupUrl, afterCloseUrl) {\n    var width  = 800,\n        height = 480,\n        position = this._computeScreenLocation(width, height),\n        windowFeatures = [\n          'width=' + width,\n          'height=' + height,\n          'top=' + position.top || 200,\n          'left=' + position.left || 200,\n          'dependent=yes',\n          'resizable=no',\n          'location=no',\n          'dialog=yes',\n          'menubar=no'\n        ],\n        exceptionCount = 0,\n        panel = window.open(popupUrl, id, windowFeatures.join()),\n        checkPanelHref = function() {\n          try {\n            /* This is a bit of a hack. Accessing a popup's location throws a security exception\n             * when the url is cross-origin. Therefore, 1) this should only be used with urls that are         cross-origin, and 2) the url\n             * should eventually return to a non-cross-origin url at the time the window should be closed.\n             */\n            var href = panel.location.href; // This will throw an exception if the url is still cross-origin.\n\n            // If exceptionCount is not 0, then we hit an external url and came back. Assume that we're done.\n            // If it's still 0, then keep waiting for the url to change to something external and change back.\n            if (exceptionCount   0) {\n              window.clearInterval(timer);\n              panel.close();\n              if (afterCloseUrl) {\n                document.location = afterCloseUrl;\n              } else {\n                document.location.reload();\n              }\n            }\n          } catch(e) {\n            exceptionCount++;\n          }\n        },\n        timer = window.setInterval(checkPanelHref, 200);\n  },\n\n  _computeScreenLocation: function(w, h) {\n    // Fixes dual-screen position                         Most browsers      Firefox\n    var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;\n    var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;\n\n    var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ?         document.documentElement.clientWidth : screen.width;\n    var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\n    var left = ((width / 2) - (w / 2)) + dualScreenLeft;\n    var top = ((height / 2) - (h / 2)) + dualScreenTop;\n    return {left: left, top: top};\n  }\n};  And it's used via this code in the page:  jQuery(function() {\n  var button = jQuery('#login_button'),\n      path = '/login',\n      popup = '/popupLogin',\n      redirect = '/';\n\n  window.AutomaticallyClosingPopupLink.configure(button, path, popup, redirect);\n});", 
            "title": "Workarounds"
        }, 
        {
            "location": "/about-mkdocs/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nRequirements:\n\n\nYou must install mkdocs to build the documentation. \npip install mkdocs\n\n\nBuild\n\n\nWhen you have \nmkdocs\n installed, \nbuild.sh\n will invoke \nmkdocs\n to build the project documentation as part of the gh-pages.\n\n\nOther Commands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "About the documentation generator"
        }, 
        {
            "location": "/about-mkdocs/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/about-mkdocs/#requirements", 
            "text": "You must install mkdocs to build the documentation.  pip install mkdocs", 
            "title": "Requirements:"
        }, 
        {
            "location": "/about-mkdocs/#build", 
            "text": "When you have  mkdocs  installed,  build.sh  will invoke  mkdocs  to build the project documentation as part of the gh-pages.", 
            "title": "Build"
        }, 
        {
            "location": "/about-mkdocs/#other-commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Other Commands"
        }, 
        {
            "location": "/about-mkdocs/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }
    ]
}