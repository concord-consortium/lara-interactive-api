{
    "docs": [
        {
            "location": "/", 
            "text": "Table of contents:\n\n\n\n\n\n\nLARA iframe APIs\n\n\nInteractive Shutterbug\n\n\nShutterbug Messages:\n\n\nhtmlFragRequest\n\n\n`htmlFragResponse\n\n\n\n\n\n\n\n\n\n\nLARA: Interactive save state\n\n\nInteractiveState  iFramePhone listeners:\n\n\nsetLearnerUrl:\n\n\ninteractiveState:\n\n\nextendedSupport:\n\n\n\n\n\n\nInteractiveState iFramePhone posts:\n\n\ngetExtendedSupport\n\n\ngetLearnerUrl\n\n\ngetInteractiveState\n\n\nloadInteractive\n\n\n\n\n\n\n\n\n\n\nLARA current_user info for an interactive\n\n\ncurrent_user Listeners:\n\n\ngetAuthInfo\n\n\n\n\n\n\ncurrent_user Posts:\n\n\nauthInfo\n\n\n\n\n\n\n\n\n\n\nInteractive Logging\n\n\nGlobal state\n\n\nGlobal state iFramePhone listeners:\n\n\ninteractiveStateGlobal:\n\n\n\n\n\n\nGlobal state iFramePhone posts:\n\n\nloadInteractiveGlobal\n\n\n\n\n\n\n\n\n\n\nOnly playing one at a time (coming soon)\n\n\n\n\n\n\nReference: using iFramePhone:\n\n\nparent setup:\n\n\niframe (child) setup:\n\n\nhello messages:\n\n\nother messages:\n\n\nMessage posting implementation:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLARA iframe APIs\n\n\nThis is an attempt to document the \npostMessage\n communication currently in use in \nLARA\n.  Some of these use \niFramePhone\n, and some use raw postMessage calls. This documentation was started from this \nPT Story\n.\n\n\nInteractive Shutterbug\n\n\nShutterbug\n is used widely in Lab and in LARA, it uses \npostMessage\n to request child iFrames HTML content for snapshotting.\n\n\nThe basic PostMessage API Calls that are used in the shutterbug javascript project are \ndocumented in the github repo\n  \n\n\nShutterbug Messages:\n\n\n\n\nhtmlFragRequest\n\n\nParent asks iframes about their content:\n\n\n var message  = {\n   type:        'htmlFragRequest',\n   id:          id,       // Shutterbug ID\n   iframeReqId: iframeId, // position of iframe in dom\n   iframeReqTimeout: this.iframeReqTimeout * 0.6\n };\n window.postMessage(JSON.stringify(message), \n*\n);\n\n\n\n\n\n\n`htmlFragResponse\n\n\n\n\n\n\n` \n\n\nAn Iframe sends its content back:\n\n\nvar response = {\n  type:        'htmlFragResponse',\n  value:       html,\n  iframeReqId: iframeReqId, // counter, from request\n  id:          id           // sender_id from request\n};\nsource.postMessage(JSON.stringify(response), \n*\n);\n\n\n\n\n\n\nLARA: Interactive save state\n\n\nLARA tries to save the interactive state in child iframes by using \niFramePhone\n, but it wraps it up in \niframe-saver.coffee\n.  The LARA logging service also uses iFramePhones \nRPC endpoint\n to log events from the interactives.\n\n\niFramePhone Handlers registered in iframe-saver.cofee:\n\n\nInteractiveState  iFramePhone listeners:\n\n\nsetLearnerUrl\n:\n\n\nListen for an attempt to set the exact URL for this current student. (In the case of Lab Interactives these are version-locked instances of the interactive). Usually sent LARA after LARA has asked for the info via a previous \ngetLearnerUrl\n message to the iFrame.\n\n\nvar learnerUrlCallback = function(learner_url) { \u2026 };\niframePhone.addListener('setLearnerUrl', learnerUrlCallback);\n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object, note that \ncontent\n is the argument sent to our callback:\n\n\nvar message = {\n  type: \nsetLearnerUrl\n, \n  content: \nhttps://lab.concord.org/version/1-0/embeddable.html?is_versioned_url=true\n\n};\n\n\n\n\ninteractiveState\n:\n\n\nListen for the current interactive state. Usually sent as a result of our having sent \ngetInteractiveState\n message to the iFrame earlier.\n\n\nvar setStateCallback = function(stateObjOrJson) { \u2026 };\niframePhone.addListener('interactiveState', setStateCallback);\n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object, note that \ncontent\n is the argument sent to our callback:\n\n\nvar message = {\n  type: \ninteractiveState\n, \n  content: {key: 'value', \u2026 } // maybe sent as Obj, or JSON depending. \n};\n\n\n\n\nextendedSupport\n:\n\n\nListen for the option to reset state using delete button.  If \nopts.reset\n is true, we will allow the user to 'reset' the interactive via the \ndelete\n button in the LARA runtime. Usually sent as a result of our having sent 'getExtendedSupport' earlier.\n\n\nvar extendSupport = function(opts) { \u2026 };\niframePhone.addListener('extendedSupport', extendSupport);\n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object, note that \ncontent\n is the argument sent to our callback:\n\n\nvar message = {\n  type: \nextendedSupport\n, \n  content: {rest: [true||false]} // maybe sent as Obj, or JSON depending. \n};\n\n\n\n\nInteractiveState iFramePhone posts:\n\n\ngetExtendedSupport\n\n\nLARA asks about extended support for things like 'reset':\n\n\niframePhone.post('getExtendedSupport');\n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.\n\n\nvar message = {\n  type: \ngetExtendedSupport\n, \n  content: {} // ignored \n};\n\n\n\n\ngetLearnerUrl\n\n\nLARA asks for the exact URL for the current student. For Lab Interactives this results in a version-specific URL:\n\n\niframePhone.post('getLearnerUrl');     \n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.\n\n\nvar message = {\n  type: \ngetLearnerUrl\n, \n  content: {} // ignored \n};\n\n\n\n\ngetInteractiveState\n\n\nLARA asks for the iframes state.\n\n\niframePhone.post('getInteractiveState');     \n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.\n\n\nvar message = {\n  type: \ngetInteractiveState\n, \n  content: {} // ignored \n};\n\n\n\n\nloadInteractive\n\n\nLARA loads interactive state if it is available in LARA activity run (so \ninteractiveState\n message has been received earlier).\n\n\nvar state = {key: 'value', \u2026 };\niframePhone.post('loadInteractive', state);     \n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.\n\n\nvar message = {\n  type: \nloadInteractive\n, \n  content: {key: 'value', \u2026 } // maybe sent as Obj, or JSON depending. \n};\n\n\n\n\n\n\nLARA current_user info for an interactive\n\n\nInformation about whether this is an anonymous run, and or who the current_user is (email) is sometimes sent to the interactive. Most of this functionality was added (possibly erroneously) to the \niframe-saver\n in  \nthese commits\n\n\ncurrent_user Listeners:\n\n\ngetAuthInfo\n\n\nLARA listens for this message. When received, LARA is being asked to send authentication iformation to the iframe for the current_user.\n\n\nvar sendAuthInfo = function() { iFramePhone.post('authInfo', \u2026) };\niframePhone.addListener('getAuthInfo', sendAuthInfo);\n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.\n\n\nvar message = {\n  type: \ngetAuthInfo\n, \n  content: {} // ignored \n};\n\n\n\n\ncurrent_user Posts:\n\n\nauthInfo\n\n\nLARA posts this in response to \ngetAuthInfo\n messages.\n\n\nvar authInfo = { \u2026 }; // get the current_user info\niframePhone.post('authInfo', authInfo);\n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.\n\n\nvar message = {\n  type: \nauthInfo\n, \n  content: {\n    provider: 'authentication-provider', \n    loggedIn: (true || false),\n    email: (undefined || 'somebody@somplace.com')\n  } \n};\n\n\n\n\n\n\nInteractive Logging\n\n\nInteractive Logging is a service that proxies communication from the interactive \u2192 LARA \u2192 Logging server.\n\n\nThere is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone:\n\n\nphone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2})\n\n\n\n\nLARA listens to these events only when logging is enabled (they will be ingored otherwise). Approprieate iframe phone handlers are installed in \nlogger.js\n. When \nlog\n message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).\n\n\n\n\nGlobal state\n\n\nGlobal state iFramePhone listeners:\n\n\ninteractiveStateGlobal\n:\n\n\nListen for the global state that should be shared with all the interactives embedded in the current activity for the current student. Usually sent by one of the embedded interactives. State is saved in DB as text (stringified JSON) and LARA does not care about its content.\n\n\nOnce this message is received, LARA immediately posts \nglobalLoadState\n to all interactives on the same page (except from the sender of the original save message).\n\n\nvar interactiveStateGlobalCallback = function(state) {\n  // Save `state` in DB, post `loadInteractiveGlobal` message. \n  ...\n};\niframePhone.addListener(\ninteractiveStateGlobal\n, interactiveStateGlobalCallback);\n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object, note that \ncontent\n is the argument sent to our callback:\n\n\nvar message = {\n  type: \ninteractiveStateGlobal\n, \n  content: {param1: \nTest\n, param2: 10} // maybe sent as Obj, or JSON depending.\n};\n\n\n\n\nGlobal state iFramePhone posts:\n\n\nloadInteractiveGlobal\n\n\nLARA sends the global interactive state (for current activity and student) to all interactives on the current page. It's interactive responsibility to interpret this message and load (or not) the given state.\n\n\nThis message is sent when:\n\n\n\n\ninteractiveStateGlobal\n message is received\n\n\nactivity page is loaded \nand\n the global interactive state is available in LARA activity run (so only if \ninteractiveStateGlobal\n has been received earlier)\n\n\n\n\n// `globalState` is retrieved from the DB or `interactiveStateGlobal` message.\nvar globalState = {param1: \nTest\n, param2: 10}; \niframePhone.post(\nloadInteractiveGlobal\n, globalState);     \n\n\n\n\niFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.\n\n\nvar message = {\n  type: \nloadInteractiveGlobal\n, \n  content: {param1: \nTest\n, param2: 10} // maybe sent as Obj, or JSON depending.\n};\n\n\n\n\n\n\nOnly playing one at a time (coming soon)\n\n\n\n\nReference: using iFramePhone:\n\n\nAs mentioned \niFramePhone\n is the service which LARA uses for much of its iFrame communication.   It is also used by Lab Interactives internally. Most of the Lab messages are ignored by LARA.  \n\n\nHere for reference is what the implementation looks like. Taken from the \niFramePhone Readme\n:\n\n\nparent setup:\n\n\nvar phone = new iframePhone.ParentEndpoint(iframeElement, function () {\n  console.log(\nconnection with iframe established\n);\n});\nphone.post('testMessage', 'abc');\nphone.addListener('response', function (content) {\n  console.log(\nparent received response: \n + content);\n});\n\n\n\n\niframe (child) setup:\n\n\nvar phone = iframePhone.getIFrameEndpoint();\nphone.addListener('testMessage', function (content) { \n  console.log(\niframe received message: \n + content);\n  phone.post('response', 'got it');\n});\n// IMPORTANT:\n// Initialize connection after all message listeners are added!\nphone.initialize();\n\n\n\n\nhello messages:\n\n\niFramePhone uses a \nhello\n messages to start communication with a specified origin. These messages get sent using the PostMessage API and look like this:\n\n\nvar message = {\n  type: \nhello\n, \n  origin: \nhttps://lab.concord.org\n\n};\n\n\n\n\nother messages:\n\n\nSubsequent messages follow a similar pattern, specifiying \ntype\n which helps determine which listeners to notify:\n\n\nvar message = {\n  type:\nmodelLoaded\n,\n  \u2026\n};\n\n\n\n\nMessage posting implementation:\n\n\nThe post messages looks like this as they are being sent out through iFramePhone. You don't need to worry about this; it is here for reference.\n\n\nmessage = {\n  type: \ngetLearnerUrl\n, \n  origin: \nhttp://localhost:3000\n,\n  content: {} // something specific to 'type'\n};\nWindow.postMessage(JSON.stringify(message), targetOrigin);", 
            "title": "LARA API"
        }, 
        {
            "location": "/#lara-iframe-apis", 
            "text": "This is an attempt to document the  postMessage  communication currently in use in  LARA .  Some of these use  iFramePhone , and some use raw postMessage calls. This documentation was started from this  PT Story .", 
            "title": "LARA iframe APIs"
        }, 
        {
            "location": "/#interactive-shutterbug", 
            "text": "Shutterbug  is used widely in Lab and in LARA, it uses  postMessage  to request child iFrames HTML content for snapshotting.  The basic PostMessage API Calls that are used in the shutterbug javascript project are  documented in the github repo     Shutterbug Messages:   htmlFragRequest  Parent asks iframes about their content:   var message  = {\n   type:        'htmlFragRequest',\n   id:          id,       // Shutterbug ID\n   iframeReqId: iframeId, // position of iframe in dom\n   iframeReqTimeout: this.iframeReqTimeout * 0.6\n };\n window.postMessage(JSON.stringify(message),  * );   `htmlFragResponse    `   An Iframe sends its content back:  var response = {\n  type:        'htmlFragResponse',\n  value:       html,\n  iframeReqId: iframeReqId, // counter, from request\n  id:          id           // sender_id from request\n};\nsource.postMessage(JSON.stringify(response),  * );", 
            "title": "Interactive Shutterbug"
        }, 
        {
            "location": "/#lara-interactive-save-state", 
            "text": "LARA tries to save the interactive state in child iframes by using  iFramePhone , but it wraps it up in  iframe-saver.coffee .  The LARA logging service also uses iFramePhones  RPC endpoint  to log events from the interactives.  iFramePhone Handlers registered in iframe-saver.cofee:  InteractiveState  iFramePhone listeners:  setLearnerUrl :  Listen for an attempt to set the exact URL for this current student. (In the case of Lab Interactives these are version-locked instances of the interactive). Usually sent LARA after LARA has asked for the info via a previous  getLearnerUrl  message to the iFrame.  var learnerUrlCallback = function(learner_url) { \u2026 };\niframePhone.addListener('setLearnerUrl', learnerUrlCallback);  iFramePhone handles this for us, but for completeness here is the raw postMessage data object, note that  content  is the argument sent to our callback:  var message = {\n  type:  setLearnerUrl , \n  content:  https://lab.concord.org/version/1-0/embeddable.html?is_versioned_url=true \n};  interactiveState :  Listen for the current interactive state. Usually sent as a result of our having sent  getInteractiveState  message to the iFrame earlier.  var setStateCallback = function(stateObjOrJson) { \u2026 };\niframePhone.addListener('interactiveState', setStateCallback);  iFramePhone handles this for us, but for completeness here is the raw postMessage data object, note that  content  is the argument sent to our callback:  var message = {\n  type:  interactiveState , \n  content: {key: 'value', \u2026 } // maybe sent as Obj, or JSON depending. \n};  extendedSupport :  Listen for the option to reset state using delete button.  If  opts.reset  is true, we will allow the user to 'reset' the interactive via the  delete  button in the LARA runtime. Usually sent as a result of our having sent 'getExtendedSupport' earlier.  var extendSupport = function(opts) { \u2026 };\niframePhone.addListener('extendedSupport', extendSupport);  iFramePhone handles this for us, but for completeness here is the raw postMessage data object, note that  content  is the argument sent to our callback:  var message = {\n  type:  extendedSupport , \n  content: {rest: [true||false]} // maybe sent as Obj, or JSON depending. \n};  InteractiveState iFramePhone posts:  getExtendedSupport  LARA asks about extended support for things like 'reset':  iframePhone.post('getExtendedSupport');  iFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.  var message = {\n  type:  getExtendedSupport , \n  content: {} // ignored \n};  getLearnerUrl  LARA asks for the exact URL for the current student. For Lab Interactives this results in a version-specific URL:  iframePhone.post('getLearnerUrl');       iFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.  var message = {\n  type:  getLearnerUrl , \n  content: {} // ignored \n};  getInteractiveState  LARA asks for the iframes state.  iframePhone.post('getInteractiveState');       iFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.  var message = {\n  type:  getInteractiveState , \n  content: {} // ignored \n};  loadInteractive  LARA loads interactive state if it is available in LARA activity run (so  interactiveState  message has been received earlier).  var state = {key: 'value', \u2026 };\niframePhone.post('loadInteractive', state);       iFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.  var message = {\n  type:  loadInteractive , \n  content: {key: 'value', \u2026 } // maybe sent as Obj, or JSON depending. \n};", 
            "title": "LARA: Interactive save state"
        }, 
        {
            "location": "/#lara-current_user-info-for-an-interactive", 
            "text": "Information about whether this is an anonymous run, and or who the current_user is (email) is sometimes sent to the interactive. Most of this functionality was added (possibly erroneously) to the  iframe-saver  in   these commits  current_user Listeners:  getAuthInfo  LARA listens for this message. When received, LARA is being asked to send authentication iformation to the iframe for the current_user.  var sendAuthInfo = function() { iFramePhone.post('authInfo', \u2026) };\niframePhone.addListener('getAuthInfo', sendAuthInfo);  iFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.  var message = {\n  type:  getAuthInfo , \n  content: {} // ignored \n};  current_user Posts:  authInfo  LARA posts this in response to  getAuthInfo  messages.  var authInfo = { \u2026 }; // get the current_user info\niframePhone.post('authInfo', authInfo);  iFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.  var message = {\n  type:  authInfo , \n  content: {\n    provider: 'authentication-provider', \n    loggedIn: (true || false),\n    email: (undefined || 'somebody@somplace.com')\n  } \n};", 
            "title": "LARA current_user info for an interactive"
        }, 
        {
            "location": "/#interactive-logging", 
            "text": "Interactive Logging is a service that proxies communication from the interactive \u2192 LARA \u2192 Logging server.  There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone:  phone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2})  LARA listens to these events only when logging is enabled (they will be ingored otherwise). Approprieate iframe phone handlers are installed in  logger.js . When  log  message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).", 
            "title": "Interactive Logging"
        }, 
        {
            "location": "/#global-state", 
            "text": "Global state iFramePhone listeners:  interactiveStateGlobal :  Listen for the global state that should be shared with all the interactives embedded in the current activity for the current student. Usually sent by one of the embedded interactives. State is saved in DB as text (stringified JSON) and LARA does not care about its content.  Once this message is received, LARA immediately posts  globalLoadState  to all interactives on the same page (except from the sender of the original save message).  var interactiveStateGlobalCallback = function(state) {\n  // Save `state` in DB, post `loadInteractiveGlobal` message. \n  ...\n};\niframePhone.addListener( interactiveStateGlobal , interactiveStateGlobalCallback);  iFramePhone handles this for us, but for completeness here is the raw postMessage data object, note that  content  is the argument sent to our callback:  var message = {\n  type:  interactiveStateGlobal , \n  content: {param1:  Test , param2: 10} // maybe sent as Obj, or JSON depending.\n};  Global state iFramePhone posts:  loadInteractiveGlobal  LARA sends the global interactive state (for current activity and student) to all interactives on the current page. It's interactive responsibility to interpret this message and load (or not) the given state.  This message is sent when:   interactiveStateGlobal  message is received  activity page is loaded  and  the global interactive state is available in LARA activity run (so only if  interactiveStateGlobal  has been received earlier)   // `globalState` is retrieved from the DB or `interactiveStateGlobal` message.\nvar globalState = {param1:  Test , param2: 10}; \niframePhone.post( loadInteractiveGlobal , globalState);       iFramePhone handles this for us, but for completeness here is the raw postMessage data object sent.  var message = {\n  type:  loadInteractiveGlobal , \n  content: {param1:  Test , param2: 10} // maybe sent as Obj, or JSON depending.\n};", 
            "title": "Global state"
        }, 
        {
            "location": "/#only-playing-one-at-a-time-coming-soon", 
            "text": "", 
            "title": "Only playing one at a time (coming soon)"
        }, 
        {
            "location": "/#reference-using-iframephone", 
            "text": "As mentioned  iFramePhone  is the service which LARA uses for much of its iFrame communication.   It is also used by Lab Interactives internally. Most of the Lab messages are ignored by LARA.    Here for reference is what the implementation looks like. Taken from the  iFramePhone Readme :  parent setup:  var phone = new iframePhone.ParentEndpoint(iframeElement, function () {\n  console.log( connection with iframe established );\n});\nphone.post('testMessage', 'abc');\nphone.addListener('response', function (content) {\n  console.log( parent received response:   + content);\n});  iframe (child) setup:  var phone = iframePhone.getIFrameEndpoint();\nphone.addListener('testMessage', function (content) { \n  console.log( iframe received message:   + content);\n  phone.post('response', 'got it');\n});\n// IMPORTANT:\n// Initialize connection after all message listeners are added!\nphone.initialize();  hello messages:  iFramePhone uses a  hello  messages to start communication with a specified origin. These messages get sent using the PostMessage API and look like this:  var message = {\n  type:  hello , \n  origin:  https://lab.concord.org \n};  other messages:  Subsequent messages follow a similar pattern, specifiying  type  which helps determine which listeners to notify:  var message = {\n  type: modelLoaded ,\n  \u2026\n};  Message posting implementation:  The post messages looks like this as they are being sent out through iFramePhone. You don't need to worry about this; it is here for reference.  message = {\n  type:  getLearnerUrl , \n  origin:  http://localhost:3000 ,\n  content: {} // something specific to 'type'\n};\nWindow.postMessage(JSON.stringify(message), targetOrigin);", 
            "title": "Reference: using iFramePhone:"
        }, 
        {
            "location": "/safari-cookies-redirects/", 
            "text": "Safari / IE, cookies and iframe redirects\n\n\nWhile recently debugging a weird authentication failure in an app that is regularly embedded within an iframe, I discovered some unexpected behavior in Safari and IE with respect to how it handles cookies for the sites within the iframe.\n\n\nThe TL;DR is this: \nCookies will not be sent to the destination site of a 302 redirect\n (the destination defined in the HTTP Location header), regardless of whether or not you've previously visited that site (unless the site is within the same main domain as the redirecting site).\n\n\nIn Safari, most of this behavior is due to the recent change of default settings. Under \nPrivacy\n -\n \nCookies and website data\n, the setting changed from \nAllow from websites I visit\n to \nAllow from current website only\n.\n\n\nThere doesn't seem to be a setting around this behavior in IE.\n\n\nExample\n\n\nOur app uses OAuth2 to sign in via a different app. The sign in process involves several redirects (these aren't the actual domains/paths, but roughly the same steps):\n\n\nRequest                            Response\nGET:  https://app.com/login        302: https://sso.com/sso/login\nGET:  https://sso.com/sso/login    200\nPOST: https://sso.com/sso/login    302: https://app.com/sso/callback\nGET:  https://app.com/sso/callback 302: https://app.com/\n\n\n\nThis all works fine in Safari when accessing app.com in a top-level window. However, this all breaks down when running within an iframe.\n\n\nIt turns out that Safari will \nnot\n send cookies to \nsso.com\n in the 2nd request, and additionally will \nnot\n send cookies to \napp.com\n in the 4th request. The whole sign in process relies on maintaining consistent sessions, so when no cookies are sent, the sign in doesn't take, and the user is left on app.com in a logged out state.\n\n\nWorkarounds\n\n\n\n\n\n\nI haven't been able to test this, but supposedly you can work around this cookie behavior by rendering a page which redirects via the page content, rather than redirecting via a 302 response with a \nLocation\n header.\n\n\nhtml\n\n  \nhead\n\n    \ntitle\nSign In\n/title\n\n    \nmeta http-equiv=\"refresh\" content=\"0;URL='https://sso.com/sso/login'\" /\n\n  \n/head\n\n  \nbody\n\n    \np\nThis page has moved to a \na href=\"https://sso.com/sso/login\"\nnew location\n/a\n.\n/p\n\n  \n/body\n\n\n/html\n\n\n\n\nHowever, you'll have to take care that the request to the other site is essentially the same (Referrer, Origin, etc all present the same info).\n\n\n\n\n\n\nAlso, Safari's definition of \ncurrent website\n is a bit loose when it comes to the hostname. foo.app.com is considered the same site as bar.app.com. We were fortunate enough to be able to use this tactic to bring our app into the same \"site\" as the sso provider, but that's not usually possible when working with a 3rd-party provider.\n\n\n\n\n\n\nIf your redirecting code makes a full round-trip, another option is to do all of your redirecting in a separate window. Use Javascript to open a window, and then monitor its url. Once the url is back to the location you're expecting, close the window and reload the iframe page.\n\n\nThe library is here:\n\n\n// A wrapper around having an external link pop up in its own window, and then automatically monitoring it\n// and closing it when it returns to the same domain as the current page.\n\nwindow.inIframe = function() {\n  try {\n      return window.self !== window.top;\n  } catch (e) {\n      return true;\n  }\n};\n\nwindow.AutomaticallyClosingPopupLink = {\n  configure: function($link, directUrl, popupUrl, afterCloseUrl) {\n    var onClick = function() {\n      if (window.inIframe()) {\n        // Pop up the url in a new window\n        // Monitor it and close it when done\n        // Redirect the current page when closed\n        this._popupWindow($link.id, popupUrl, afterCloseUrl);\n      } else {\n        window.location.href = directUrl;\n      }\n    }.bind(this);\n    $link.on('click', onClick);\n  },\n\n  // This code was adapted from CODAP's implementation of a similar feature\n  _popupWindow: function(id, popupUrl, afterCloseUrl) {\n    var width  = 800,\n        height = 480,\n        position = this._computeScreenLocation(width, height),\n        windowFeatures = [\n          'width=' + width,\n          'height=' + height,\n          'top=' + position.top || 200,\n          'left=' + position.left || 200,\n          'dependent=yes',\n          'resizable=no',\n          'location=no',\n          'dialog=yes',\n          'menubar=no'\n        ],\n        exceptionCount = 0,\n        panel = window.open(popupUrl, id, windowFeatures.join()),\n        checkPanelHref = function() {\n          try {\n            /* This is a bit of a hack. Accessing a popup's location throws a security exception\n             * when the url is cross-origin. Therefore, 1) this should only be used with urls that are         cross-origin, and 2) the url\n             * should eventually return to a non-cross-origin url at the time the window should be closed.\n             */\n            var href = panel.location.href; // This will throw an exception if the url is still cross-origin.\n\n            // If exceptionCount is not 0, then we hit an external url and came back. Assume that we're done.\n            // If it's still 0, then keep waiting for the url to change to something external and change back.\n            if (exceptionCount \n 0) {\n              window.clearInterval(timer);\n              panel.close();\n              if (afterCloseUrl) {\n                document.location = afterCloseUrl;\n              } else {\n                document.location.reload();\n              }\n            }\n          } catch(e) {\n            exceptionCount++;\n          }\n        },\n        timer = window.setInterval(checkPanelHref, 200);\n  },\n\n  _computeScreenLocation: function(w, h) {\n    // Fixes dual-screen position                         Most browsers      Firefox\n    var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;\n    var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;\n\n    var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ?         document.documentElement.clientWidth : screen.width;\n    var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\n    var left = ((width / 2) - (w / 2)) + dualScreenLeft;\n    var top = ((height / 2) - (h / 2)) + dualScreenTop;\n    return {left: left, top: top};\n  }\n};\n\n\n\nAnd it's used via this code in the page:\n\n\njQuery(function() {\n  var button = jQuery('#login_button'),\n      path = '/login',\n      popup = '/popupLogin',\n      redirect = '/';\n\n  window.AutomaticallyClosingPopupLink.configure(button, path, popup, redirect);\n});", 
            "title": "Safari / IE, cookies and iframe redirects"
        }, 
        {
            "location": "/safari-cookies-redirects/#safari-ie-cookies-and-iframe-redirects", 
            "text": "While recently debugging a weird authentication failure in an app that is regularly embedded within an iframe, I discovered some unexpected behavior in Safari and IE with respect to how it handles cookies for the sites within the iframe.  The TL;DR is this:  Cookies will not be sent to the destination site of a 302 redirect  (the destination defined in the HTTP Location header), regardless of whether or not you've previously visited that site (unless the site is within the same main domain as the redirecting site).  In Safari, most of this behavior is due to the recent change of default settings. Under  Privacy  -   Cookies and website data , the setting changed from  Allow from websites I visit  to  Allow from current website only .  There doesn't seem to be a setting around this behavior in IE.", 
            "title": "Safari / IE, cookies and iframe redirects"
        }, 
        {
            "location": "/safari-cookies-redirects/#example", 
            "text": "Our app uses OAuth2 to sign in via a different app. The sign in process involves several redirects (these aren't the actual domains/paths, but roughly the same steps):  Request                            Response\nGET:  https://app.com/login        302: https://sso.com/sso/login\nGET:  https://sso.com/sso/login    200\nPOST: https://sso.com/sso/login    302: https://app.com/sso/callback\nGET:  https://app.com/sso/callback 302: https://app.com/  This all works fine in Safari when accessing app.com in a top-level window. However, this all breaks down when running within an iframe.  It turns out that Safari will  not  send cookies to  sso.com  in the 2nd request, and additionally will  not  send cookies to  app.com  in the 4th request. The whole sign in process relies on maintaining consistent sessions, so when no cookies are sent, the sign in doesn't take, and the user is left on app.com in a logged out state.", 
            "title": "Example"
        }, 
        {
            "location": "/safari-cookies-redirects/#workarounds", 
            "text": "I haven't been able to test this, but supposedly you can work around this cookie behavior by rendering a page which redirects via the page content, rather than redirecting via a 302 response with a  Location  header.  html \n   head \n     title Sign In /title \n     meta http-equiv=\"refresh\" content=\"0;URL='https://sso.com/sso/login'\" / \n   /head \n   body \n     p This page has moved to a  a href=\"https://sso.com/sso/login\" new location /a . /p \n   /body  /html   However, you'll have to take care that the request to the other site is essentially the same (Referrer, Origin, etc all present the same info).    Also, Safari's definition of  current website  is a bit loose when it comes to the hostname. foo.app.com is considered the same site as bar.app.com. We were fortunate enough to be able to use this tactic to bring our app into the same \"site\" as the sso provider, but that's not usually possible when working with a 3rd-party provider.    If your redirecting code makes a full round-trip, another option is to do all of your redirecting in a separate window. Use Javascript to open a window, and then monitor its url. Once the url is back to the location you're expecting, close the window and reload the iframe page.  The library is here:  // A wrapper around having an external link pop up in its own window, and then automatically monitoring it\n// and closing it when it returns to the same domain as the current page.\n\nwindow.inIframe = function() {\n  try {\n      return window.self !== window.top;\n  } catch (e) {\n      return true;\n  }\n};\n\nwindow.AutomaticallyClosingPopupLink = {\n  configure: function($link, directUrl, popupUrl, afterCloseUrl) {\n    var onClick = function() {\n      if (window.inIframe()) {\n        // Pop up the url in a new window\n        // Monitor it and close it when done\n        // Redirect the current page when closed\n        this._popupWindow($link.id, popupUrl, afterCloseUrl);\n      } else {\n        window.location.href = directUrl;\n      }\n    }.bind(this);\n    $link.on('click', onClick);\n  },\n\n  // This code was adapted from CODAP's implementation of a similar feature\n  _popupWindow: function(id, popupUrl, afterCloseUrl) {\n    var width  = 800,\n        height = 480,\n        position = this._computeScreenLocation(width, height),\n        windowFeatures = [\n          'width=' + width,\n          'height=' + height,\n          'top=' + position.top || 200,\n          'left=' + position.left || 200,\n          'dependent=yes',\n          'resizable=no',\n          'location=no',\n          'dialog=yes',\n          'menubar=no'\n        ],\n        exceptionCount = 0,\n        panel = window.open(popupUrl, id, windowFeatures.join()),\n        checkPanelHref = function() {\n          try {\n            /* This is a bit of a hack. Accessing a popup's location throws a security exception\n             * when the url is cross-origin. Therefore, 1) this should only be used with urls that are         cross-origin, and 2) the url\n             * should eventually return to a non-cross-origin url at the time the window should be closed.\n             */\n            var href = panel.location.href; // This will throw an exception if the url is still cross-origin.\n\n            // If exceptionCount is not 0, then we hit an external url and came back. Assume that we're done.\n            // If it's still 0, then keep waiting for the url to change to something external and change back.\n            if (exceptionCount   0) {\n              window.clearInterval(timer);\n              panel.close();\n              if (afterCloseUrl) {\n                document.location = afterCloseUrl;\n              } else {\n                document.location.reload();\n              }\n            }\n          } catch(e) {\n            exceptionCount++;\n          }\n        },\n        timer = window.setInterval(checkPanelHref, 200);\n  },\n\n  _computeScreenLocation: function(w, h) {\n    // Fixes dual-screen position                         Most browsers      Firefox\n    var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;\n    var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;\n\n    var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ?         document.documentElement.clientWidth : screen.width;\n    var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\n    var left = ((width / 2) - (w / 2)) + dualScreenLeft;\n    var top = ((height / 2) - (h / 2)) + dualScreenTop;\n    return {left: left, top: top};\n  }\n};  And it's used via this code in the page:  jQuery(function() {\n  var button = jQuery('#login_button'),\n      path = '/login',\n      popup = '/popupLogin',\n      redirect = '/';\n\n  window.AutomaticallyClosingPopupLink.configure(button, path, popup, redirect);\n});", 
            "title": "Workarounds"
        }, 
        {
            "location": "/about-mkdocs/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nRequirements:\n\n\nYou must install mkdocs to build the documentation. \npip install mkdocs\n\n\nBuild\n\n\nWhen you have \nmkdocs\n installed, \nbuild.sh\n will invoke \nmkdocs\n to build the project documentation as part of the gh-pages.\n\n\nOther Commands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "About the documentation generator"
        }, 
        {
            "location": "/about-mkdocs/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/about-mkdocs/#requirements", 
            "text": "You must install mkdocs to build the documentation.  pip install mkdocs", 
            "title": "Requirements:"
        }, 
        {
            "location": "/about-mkdocs/#build", 
            "text": "When you have  mkdocs  installed,  build.sh  will invoke  mkdocs  to build the project documentation as part of the gh-pages.", 
            "title": "Build"
        }, 
        {
            "location": "/about-mkdocs/#other-commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Other Commands"
        }, 
        {
            "location": "/about-mkdocs/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }
    ]
}