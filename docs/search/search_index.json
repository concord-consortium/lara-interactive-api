{
    "docs": [
        {
            "location": "/implementing-interactive/", 
            "text": "Implementing Interactive\n\uf0c1\n\n\nLARA embeds interactives using iframe and provides LARA Interactive API. This API can be used e.g. to customize interactive,\nsave state authored by teachers or save student progress. The whole communication between LARA and Interactive\nhappens through \niFramePhone\n which is a simple wrapper around\n\npostMessage\n API. Interactive which wants to use LARA Interactive API needs to use this library. Check its\nreadme to see how to include it in your project (npm, RequireJS or via script tag). Once \niframePhone\n library is\navailable, Interactive needs to setup communication:\n\n\niframe-phone setup\n\uf0c1\n\n\nvar phone = iframePhone.getIFrameEndpoint();\nphone.addListener('initInteractive', function (data) {\n  // handle initInteractive call\n});\nphone.addListener('otherMessageType', function (data) {\n  // handle otherMessageType call\n});\n// more handlers here\n\n// IMPORTANT: Initialize connection after all message listeners are added!\nphone.initialize();\n// Inform LARA about supported features. Some of them require that\n//  (e.g. state authoring, student progress saving):\nphone.post('supportedFeatures', {\n  apiVersion: 1,\n  features: {\n    someFeature: true\n    otherFeature: true\n  }\n});\n\n\n\n\nHandling the \ninitInteractive\n message\n\uf0c1\n\n\nThis is one of the most important messages sent by LARA. It provides most of the information stored by LARA.\nIt tells the interactive what is the current API version, mode (\nruntime\n or \nauthoring\n), \nauthoredState\n\n(state defined by author), \ninteractiveState\n (state based on student work) and so on. Interactive should\nadd \ninitInteractive\n handler that reads values stored in \ndata\n Object / hash:\n\n\nphone.addListener('initInteractive', function (data) {\n  // process data object, e.g.:\n  initializeMode(data.mode);\n  loadAuthoredState(data.authoredState);\n  loadStudentWork(data.interactiveState);\n});\n\n\n\n\nData passed to initInteractive\n\uf0c1\n\n\n\n\nerror\n - \nnull\n if everything is okay, error message otherwise (e.g. data fetching might fail).\n\n\nmode\n - \n\"authoring\"\n or \n\"runtime\"\n. Interactive can be displayed in one of those two modes, but it's up to interactive whether it supports authoring mode. Runtime is basic mode which is presented to students. Authoring mode can be used by authors to customize interactive.\n\n\nauthoredState [optional]\n - JSON that has been saved by interactive earlier in authoring mode using \nauthoredState\n message (described below in other section). If it's not defined, it would be falsy value (null or empty string).\n\n\ninteractiveState [optional]\n - JSON that has been saved by interactive earlier in runtime mode using \ninteractiveState\n message. More detail in \nSaving Student Progress section\n. Provided only in runtime mode. If it's not defined, it would be falsy value (null or empty string).\n\n\nglobalInteractiveState [optional]\n - JSON that has been saved by any interactive in the same activity earlier in runtime mode using \nglobalInteractiveState message\n. Provided only in runtime mode. If it's not defined, it would be falsy value (null or empty string).\n\n\nhasLinkedInteractive [optional]\n - boolean or undefined. If this is true then the author has linked this interactive to another interactive in the activity or sequence. This will be true even if the linked interactive has not saved state yet.\n\n\nlinkedState [optional]\n - JSON that has been saved by the linked interactive. If no state has been saved this will be falsy.\n\n\ninteractiveStateUrl [optional]\n - Fully qualified URL to access the interactive state externally. See \nAccessing Interactive State with HTTP\n for more information.\n\n\ncollaboratorUrls [optional]\n - Fully qualified URL to access the interactive state of each collaborator working with the current student. These URLs can be used to save a copy of the work into each collaborator's interactive state.\n\n\n\n\nInteractive customization\n\uf0c1\n\n\nIf interactive wants to support customization, it should inform LARA about it using \nsupportedFeatures\n message:\n\n\nphone.post('supportedFeatures', {\n  apiVersion: 1,\n  features: {\n    authoredState: true\n    // + other supported features\n  }\n});\n\n\n\n\ninitInteractive\n message provides \nmode\n property. Interactive can display authoring interface when mode value is equal to \n\"authoring\"\n. Every customization made by author should be sent back to LARA using \nauthoredState\n message:\n\n\nphone.post('authoredState', data);\n\n\n\n\nThe authoredState data should be a JSON compatible object, that is the only requirement. Next time the interactive is loaded either in authoring or runtime mode, \ninitInteractive\n will provide this state to the interactive in \nauthoredState\n property. Note that it's recommended that \nauthoredState\n should be sent to LARA immediately after every change. LARA provides its own \"Save\" button that would actually save this state to the DB and \"Reset\" which would set it back to null.\n\n\nSaving student progress\n\uf0c1\n\n\nIf interactive wants to support student progress saving, it should inform LARA about it using \nsupportedFeatures\n message:\n\n\nphone.post('supportedFeatures', {\n  apiVersion: 1,\n  features: {\n    interactiveState: true\n    // + other supported features\n  }\n});\n\n\n\n\nCurrently, LARA is not paying attention to this interactiveState supportedFeature, but it will do so in the future.\n\n\nWhen this interactive is added to a LARA page the author needs to check the \"save state\" checkbox.\n\n\ninitInteractive\n provides \nmode\n property. \n\"runtime\"\n mode means that Interactive is viewed by student. Interactive\n can save student progress using \ninteractiveState\n message:\n\n\nphone.post('interactiveState', data);\n\n\n\n\nNormally the interactiveState data should be a JSON compatible object, that is the only requirement. Next time the interactive is loaded in runtime mode, \ninitInteractive\n will provide this state to the interactive in \ninteractiveState\n property.\n\n\nLARA will send the interactive a \ngetInteractiveState\n periodically:\n\n\n\n\nevery 5 seconds\n\n\non window focus\n\n\niframe mouseout\n\n\nwhen the student tries to leave the page containing the interactive\n\n\n\n\nThe interactive should add a listener for \ngetInteractiveState\n. To be safe, remember to add the listener before calling \nphone.initialize();\n. Here is an example listener:\n\n\nphone.addListener('getInteractiveState', function () {\n  phone.post('interactiveState', interactiveState);\n});\n\n\n\n\nIMPORTANT\n When the student tries to leave the page with the interactive, the interactive needs to respond with an \ninteractiveState\n message. LARA will not changes pages until it receives this message.\n\n\nThere is a special value \n\"nochange\"\n, that can be sent as the interactiveState data. This tells LARA the interactiveState has not changed since the last time. This is useful when responding to getInteractiveState\n\n\nCustom learner URL\n\uf0c1\n\n\nDEPRECATED\n This feature is related to student progress saving. Interactive can provide versioned URL to make sure that the given data format is always supported. Otherwise the interactive might be updated and not be able to open the old state format.\n\n\nThis is deprecated because it causes more problems than it is worth. We have wanted to remove support for old versions of interactives, and we've had to remember to go through all of the interactive states and these learner urls.  Also the concept of saving a URL that works in this maner is confusing. Sometimes the interactive is loaded with the authored URL sometimes it is loaded with the saved URL. So a set of students or testers might see different versions of what seems like it should be the same interactive. Instead of using this approach to handle old state, the interactive should handle migrating its own old state. If migrating its own state isn't practical then please work with the LARA developers to do a batch migration on the server.\n\n\nphone.post('setLearnerUrl', 'https://my.example.interactive/version/1');\n\n\n\n\nGlobal interactive state\n\uf0c1\n\n\nA few interactives can share one global state within a single LARA activity. E.g. you can let students work on the same model on different pages of the activity. Interactive can set global state using \ninteractiveStateGlobal\n message:\n\n\nphone.post('interactiveStateGlobal', globalState);\n\n\n\n\nOnce this message is received, the server immediately posts \nloadInteractiveGlobal\n to all interactives on the same page (except from the sender of the original save message). So, interactives can listen to this message:\n\n\nphone.addListener('loadInteraciveGlobal', function (globalState) {\n  // Process global state, e.g.:\n  loadState(globalState);\n});\n\n\n\n\nIf one of the interactives has sent \ninteractiveStateGlobal\n message before another interactive is initialized then the global state will be provided in the \ninitInteractive\n message.\n\n\nNOTE\n Another way to communicate between two interactives is with\n\nLinked Interactives\n.\n\n\nLogging\n\uf0c1\n\n\nThis message proxies communication from the interactive \u2192 LARA \u2192 Logging server. There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone:\n\n\nphone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2}});\n\n\n\n\nLARA listens to these events only when logging is enabled (they will be ignored otherwise). When a \nlog\n message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).\n\n\nAuth info\n\uf0c1\n\n\nInteractive can ask LARA about the current users authentication information using \ngetAuthInfo\n message. It has no payload data:\n\n\nphone.post('getAuthInfo');\n\n\n\n\nLARA responds using \nauthInfo\n message:\n\n\nphone.addListener('authInfo', function (info) {\n  // ...\n});  \n\n\n\n\nThe payload is the object \n{provider: \nstring\n, loggedIn: \nboolean\n, email: \nstring\n}\n where \nprovider\n and \nloggedIn\n are always set and \nemail\n is only set if the user has an email address.\n\n\ngetExtendedSupport\n\uf0c1\n\n\nThis is a message sent by LARA to the interactive. The interactive can respond with a \nextendedSupport\n message. The data of the \nextendedSupport\n only supports one property \nreset\n. The value of reset should be boolean. If the interactive sends \nreset: true\n then LARA will show a button below the interactive for clearing the interactive state and reloading the interactive.  If \nreset: false\n then LARA will not show this button. By default LARA will show this button.\n\n\nNOTE\n this extended support message is out of date. It is the only way to hide the reset button, so it isn't deprecated. New options like this will be added to the \nsupportedFeatures\n message described above.\n\n\nLinked interactives\n\uf0c1\n\n\nEach interactive in LARA can be linked with one other interactive in the same activity\nor sequence. A LARA author edits the main interactive and can add a reference to the\nlinked interactive. Currently this reference is with an interactive id, but that\nreferencing mechanism could change and it should not effect how the interactives are\nimplemented.\n\n\nWhen the main interactive is loaded it will be sent the \ninitInteractive\n message just\nlike normal.  This message has 2 fields in related to linked interactives.\n\n\nThe \nhasLinkedInteractive\n field will be set to true if the author has setup the\nlinking.  This will be true even if the learner hasn't done any work on the linked\ninteractive yet.\n\n\nThe \nlinkedState\n field will contain the work the learner has done on the linked\ninteractive. It will be falsy if the student hasn't done any work.\n\n\nAn example use case is an activity where a student is incrementally building a  diagram.\nIn interactive 1 the student fills out part of the diagram and then in interactive 2\nthe student is asked to add more to the diagram.  Interactive 2 can load in the state\nfrom the interactive 1 and display the diagram the student created before. Any new\nchanges made can be saved separately into interactive 2's state.  The state of\ninteractive 1 will be preserved.\n\n\nThe main interactive can use the \nhasLinkedInteractive\n field to tell the difference\nbetween being used independently in the activity or being linked to another\ninteractive.  In the diagram example above, if interactive 2 sees there is no\nlinkedState, it should then check \nhasLinkedInteractive\n.  In that case it could tell\nthe student \"you should complete the previous diagram before starting this one\". If\n\nhasLinkedInteractive\n is falsy then the interactive knows it shouldn't show this\nmessage.\n\n\nAccessing Interactive State with HTTP\n\uf0c1\n\n\nTODO", 
            "title": "Implementing Interactive"
        }, 
        {
            "location": "/implementing-interactive/#implementing-interactive", 
            "text": "LARA embeds interactives using iframe and provides LARA Interactive API. This API can be used e.g. to customize interactive,\nsave state authored by teachers or save student progress. The whole communication between LARA and Interactive\nhappens through  iFramePhone  which is a simple wrapper around postMessage  API. Interactive which wants to use LARA Interactive API needs to use this library. Check its\nreadme to see how to include it in your project (npm, RequireJS or via script tag). Once  iframePhone  library is\navailable, Interactive needs to setup communication:", 
            "title": "Implementing Interactive"
        }, 
        {
            "location": "/implementing-interactive/#iframe-phone-setup", 
            "text": "var phone = iframePhone.getIFrameEndpoint();\nphone.addListener('initInteractive', function (data) {\n  // handle initInteractive call\n});\nphone.addListener('otherMessageType', function (data) {\n  // handle otherMessageType call\n});\n// more handlers here\n\n// IMPORTANT: Initialize connection after all message listeners are added!\nphone.initialize();\n// Inform LARA about supported features. Some of them require that\n//  (e.g. state authoring, student progress saving):\nphone.post('supportedFeatures', {\n  apiVersion: 1,\n  features: {\n    someFeature: true\n    otherFeature: true\n  }\n});", 
            "title": "iframe-phone setup"
        }, 
        {
            "location": "/implementing-interactive/#handling-the-initinteractive-message", 
            "text": "This is one of the most important messages sent by LARA. It provides most of the information stored by LARA.\nIt tells the interactive what is the current API version, mode ( runtime  or  authoring ),  authoredState \n(state defined by author),  interactiveState  (state based on student work) and so on. Interactive should\nadd  initInteractive  handler that reads values stored in  data  Object / hash:  phone.addListener('initInteractive', function (data) {\n  // process data object, e.g.:\n  initializeMode(data.mode);\n  loadAuthoredState(data.authoredState);\n  loadStudentWork(data.interactiveState);\n});", 
            "title": "Handling the initInteractive message"
        }, 
        {
            "location": "/implementing-interactive/#data-passed-to-initinteractive", 
            "text": "error  -  null  if everything is okay, error message otherwise (e.g. data fetching might fail).  mode  -  \"authoring\"  or  \"runtime\" . Interactive can be displayed in one of those two modes, but it's up to interactive whether it supports authoring mode. Runtime is basic mode which is presented to students. Authoring mode can be used by authors to customize interactive.  authoredState [optional]  - JSON that has been saved by interactive earlier in authoring mode using  authoredState  message (described below in other section). If it's not defined, it would be falsy value (null or empty string).  interactiveState [optional]  - JSON that has been saved by interactive earlier in runtime mode using  interactiveState  message. More detail in  Saving Student Progress section . Provided only in runtime mode. If it's not defined, it would be falsy value (null or empty string).  globalInteractiveState [optional]  - JSON that has been saved by any interactive in the same activity earlier in runtime mode using  globalInteractiveState message . Provided only in runtime mode. If it's not defined, it would be falsy value (null or empty string).  hasLinkedInteractive [optional]  - boolean or undefined. If this is true then the author has linked this interactive to another interactive in the activity or sequence. This will be true even if the linked interactive has not saved state yet.  linkedState [optional]  - JSON that has been saved by the linked interactive. If no state has been saved this will be falsy.  interactiveStateUrl [optional]  - Fully qualified URL to access the interactive state externally. See  Accessing Interactive State with HTTP  for more information.  collaboratorUrls [optional]  - Fully qualified URL to access the interactive state of each collaborator working with the current student. These URLs can be used to save a copy of the work into each collaborator's interactive state.", 
            "title": "Data passed to initInteractive"
        }, 
        {
            "location": "/implementing-interactive/#interactive-customization", 
            "text": "If interactive wants to support customization, it should inform LARA about it using  supportedFeatures  message:  phone.post('supportedFeatures', {\n  apiVersion: 1,\n  features: {\n    authoredState: true\n    // + other supported features\n  }\n});  initInteractive  message provides  mode  property. Interactive can display authoring interface when mode value is equal to  \"authoring\" . Every customization made by author should be sent back to LARA using  authoredState  message:  phone.post('authoredState', data);  The authoredState data should be a JSON compatible object, that is the only requirement. Next time the interactive is loaded either in authoring or runtime mode,  initInteractive  will provide this state to the interactive in  authoredState  property. Note that it's recommended that  authoredState  should be sent to LARA immediately after every change. LARA provides its own \"Save\" button that would actually save this state to the DB and \"Reset\" which would set it back to null.", 
            "title": "Interactive customization"
        }, 
        {
            "location": "/implementing-interactive/#saving-student-progress", 
            "text": "If interactive wants to support student progress saving, it should inform LARA about it using  supportedFeatures  message:  phone.post('supportedFeatures', {\n  apiVersion: 1,\n  features: {\n    interactiveState: true\n    // + other supported features\n  }\n});  Currently, LARA is not paying attention to this interactiveState supportedFeature, but it will do so in the future.  When this interactive is added to a LARA page the author needs to check the \"save state\" checkbox.  initInteractive  provides  mode  property.  \"runtime\"  mode means that Interactive is viewed by student. Interactive\n can save student progress using  interactiveState  message:  phone.post('interactiveState', data);  Normally the interactiveState data should be a JSON compatible object, that is the only requirement. Next time the interactive is loaded in runtime mode,  initInteractive  will provide this state to the interactive in  interactiveState  property.  LARA will send the interactive a  getInteractiveState  periodically:   every 5 seconds  on window focus  iframe mouseout  when the student tries to leave the page containing the interactive   The interactive should add a listener for  getInteractiveState . To be safe, remember to add the listener before calling  phone.initialize(); . Here is an example listener:  phone.addListener('getInteractiveState', function () {\n  phone.post('interactiveState', interactiveState);\n});  IMPORTANT  When the student tries to leave the page with the interactive, the interactive needs to respond with an  interactiveState  message. LARA will not changes pages until it receives this message.  There is a special value  \"nochange\" , that can be sent as the interactiveState data. This tells LARA the interactiveState has not changed since the last time. This is useful when responding to getInteractiveState", 
            "title": "Saving student progress"
        }, 
        {
            "location": "/implementing-interactive/#custom-learner-url", 
            "text": "DEPRECATED  This feature is related to student progress saving. Interactive can provide versioned URL to make sure that the given data format is always supported. Otherwise the interactive might be updated and not be able to open the old state format.  This is deprecated because it causes more problems than it is worth. We have wanted to remove support for old versions of interactives, and we've had to remember to go through all of the interactive states and these learner urls.  Also the concept of saving a URL that works in this maner is confusing. Sometimes the interactive is loaded with the authored URL sometimes it is loaded with the saved URL. So a set of students or testers might see different versions of what seems like it should be the same interactive. Instead of using this approach to handle old state, the interactive should handle migrating its own old state. If migrating its own state isn't practical then please work with the LARA developers to do a batch migration on the server.  phone.post('setLearnerUrl', 'https://my.example.interactive/version/1');", 
            "title": "Custom learner URL"
        }, 
        {
            "location": "/implementing-interactive/#global-interactive-state", 
            "text": "A few interactives can share one global state within a single LARA activity. E.g. you can let students work on the same model on different pages of the activity. Interactive can set global state using  interactiveStateGlobal  message:  phone.post('interactiveStateGlobal', globalState);  Once this message is received, the server immediately posts  loadInteractiveGlobal  to all interactives on the same page (except from the sender of the original save message). So, interactives can listen to this message:  phone.addListener('loadInteraciveGlobal', function (globalState) {\n  // Process global state, e.g.:\n  loadState(globalState);\n});  If one of the interactives has sent  interactiveStateGlobal  message before another interactive is initialized then the global state will be provided in the  initInteractive  message.  NOTE  Another way to communicate between two interactives is with Linked Interactives .", 
            "title": "Global interactive state"
        }, 
        {
            "location": "/implementing-interactive/#logging", 
            "text": "This message proxies communication from the interactive \u2192 LARA \u2192 Logging server. There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone:  phone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2}});  LARA listens to these events only when logging is enabled (they will be ignored otherwise). When a  log  message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).", 
            "title": "Logging"
        }, 
        {
            "location": "/implementing-interactive/#auth-info", 
            "text": "Interactive can ask LARA about the current users authentication information using  getAuthInfo  message. It has no payload data:  phone.post('getAuthInfo');  LARA responds using  authInfo  message:  phone.addListener('authInfo', function (info) {\n  // ...\n});    The payload is the object  {provider:  string , loggedIn:  boolean , email:  string }  where  provider  and  loggedIn  are always set and  email  is only set if the user has an email address.", 
            "title": "Auth info"
        }, 
        {
            "location": "/implementing-interactive/#getextendedsupport", 
            "text": "This is a message sent by LARA to the interactive. The interactive can respond with a  extendedSupport  message. The data of the  extendedSupport  only supports one property  reset . The value of reset should be boolean. If the interactive sends  reset: true  then LARA will show a button below the interactive for clearing the interactive state and reloading the interactive.  If  reset: false  then LARA will not show this button. By default LARA will show this button.  NOTE  this extended support message is out of date. It is the only way to hide the reset button, so it isn't deprecated. New options like this will be added to the  supportedFeatures  message described above.", 
            "title": "getExtendedSupport"
        }, 
        {
            "location": "/implementing-interactive/#linked-interactives", 
            "text": "Each interactive in LARA can be linked with one other interactive in the same activity\nor sequence. A LARA author edits the main interactive and can add a reference to the\nlinked interactive. Currently this reference is with an interactive id, but that\nreferencing mechanism could change and it should not effect how the interactives are\nimplemented.  When the main interactive is loaded it will be sent the  initInteractive  message just\nlike normal.  This message has 2 fields in related to linked interactives.  The  hasLinkedInteractive  field will be set to true if the author has setup the\nlinking.  This will be true even if the learner hasn't done any work on the linked\ninteractive yet.  The  linkedState  field will contain the work the learner has done on the linked\ninteractive. It will be falsy if the student hasn't done any work.  An example use case is an activity where a student is incrementally building a  diagram.\nIn interactive 1 the student fills out part of the diagram and then in interactive 2\nthe student is asked to add more to the diagram.  Interactive 2 can load in the state\nfrom the interactive 1 and display the diagram the student created before. Any new\nchanges made can be saved separately into interactive 2's state.  The state of\ninteractive 1 will be preserved.  The main interactive can use the  hasLinkedInteractive  field to tell the difference\nbetween being used independently in the activity or being linked to another\ninteractive.  In the diagram example above, if interactive 2 sees there is no\nlinkedState, it should then check  hasLinkedInteractive .  In that case it could tell\nthe student \"you should complete the previous diagram before starting this one\". If hasLinkedInteractive  is falsy then the interactive knows it shouldn't show this\nmessage.", 
            "title": "Linked interactives"
        }, 
        {
            "location": "/implementing-interactive/#accessing-interactive-state-with-http", 
            "text": "TODO", 
            "title": "Accessing Interactive State with HTTP"
        }, 
        {
            "location": "/", 
            "text": "LARA Interactive API\n\uf0c1\n\n\nTable of contents:\n\n\n\n\n\n\nLARA Interactive API\n\n\nStartup and Initialization\n\n\niframe-saver.coffee Messages\n\n\ngetExtendedSupport\n\n\nextendedSupport\n\n\ngetLearnerUrl\n\n\nsetLearnerUrl\n\n\ngetInteractiveState\n\n\ninteractiveState\n\n\ngetAuthInfo\n\n\nauthInfo\n\n\nloadInteractive\n\n\ninitInteractive\n\n\n\n\n\n\nglobal-iframe-saver.coffee Messages\n\n\ninteractiveStateGlobal\n\n\nloadInteractiveGlobal\n\n\n\n\n\n\nlogger.js Messages\n\n\nlog\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStartup and Initialization\n\uf0c1\n\n\nLARA interactive iframes communicate by using \niFramePhone\n through three scripts loaded by the server in the browser:  \niframe-saver.coffee\n,\n\nglobal-iframe-saver.coffee\n and\n\nlogger.js\n.  The LARA logging service also uses iFramePhones \nRPC endpoint\n to log events from the interactives.\n\n\nThe iframe-saver.coffee script first listens for the iFramePhone to connect and registers the message handlers documented below, then sends separate \ngetExtendedSupport\n and \ngetLearnerUrl\n\nrequests to the client and finally calls back to the LARA server to get the current interactive state.  If there is existing interactive state the client will receive a \nloadInteractive\n message with the current interactive state as the parameter to the message.  However if no previous interactive state is found on the server the client will \nnot\n receive a callback.  To allow interactives to have a\nconsistent startup a new message was added, \ninitInteractive\n (documented below), which is always sent to the client after the server is queried for the interactive state by iframe-saver.coffee.\n\n\nThe global-iframe-saver.coffee script sets up a listener for the \ninteractiveStateGlobal\n message and sends one message: \nloadInteractiveGlobal\n.\n\n\nThe logger.js sets up a listener for the \nlog\n message.\n\n\nSince the three scripts above and the interactive's code are both running in the browser we will use the term server to mean the code in scripts interfacing with LARA above and client to be the interactive.\n\n\niframe-saver.coffee Messages\n\uf0c1\n\n\nThe client-side API can be split into two parts: messages initiated by the server to inform the client or request data back from the client and those initiated by the client to inform the server or request data back from the server.  Some of the messages from the client can be both responses to the server when it queries for information and requests to the server to set that information.\n\n\ngetExtendedSupport\n\uf0c1\n\n\nSent automatically by the server at startup to query the client about their \nextendedSupport\n status.  This is the first message the client will receive and is sent before the call is made to\nthe server to get the interactive state.  It has no payload data.\n\n\nextendedSupport\n\uf0c1\n\n\nCan be thought of as \nsetExtendedSupport\n. Sent by the client either in response to receiving a \ngetExtendedSupport\n message or can be initiated by the client.  The payload for the message is an object with the following structure: \n{reset: \nboolean\n}\n.  If \nreset\n is true, we will allow the user to 'reset' the interactive via the \ndelete\n button in the LARA runtime.\n\n\ngetLearnerUrl\n\uf0c1\n\n\nDEPRECATED\n instead you should use the messages that save and load interactive state: \ninitInteractive\n, \ngetInteractiveState\n, \ninteractiveState\n\n\nSent automatically by the server at startup to query the client about their learner url (the client responds via \nsetLearnerUrl\n).  This is the second message the client will receive and is sent before the call is made to the server to get the interactive state.  It has no payload data.\n\n\nsetLearnerUrl\n\uf0c1\n\n\nDEPRECATED\n instead you should use the messages that save and load interactive state: \ninitInteractive\n, \ngetInteractiveState\n, \ninteractiveState\n\n\nSent by the client either in response to receiving a \ngetLearnerUrl\n message or can be initiated by the client. The payload for the message is the string that denotes exact URL for the current student.\n\n\ngetInteractiveState\n\uf0c1\n\n\nSent automatically by the server every 5 seconds to query the client about their interactive state. It has no payload data.\n\n\nThis is also sent by LARA before changing pages.  The client must respond with \ninitInteractive\n.\n\n\nIMPORTANT\n If the client does not respond with the \ninteractiveState\n message then LARA will not change pages.\n\n\ninteractiveState\n\uf0c1\n\n\nCan be thought of as \nsetInteractiveState\n. Sent by the client either in response to receiving a \ngetInteractiveState\n message or can be initiated by the client.  The payload for the message is an arbitrary serializable object that will be stored by the LARA server.\n\n\ngetAuthInfo\n\uf0c1\n\n\nSent by the client to the server to request the current users authentication information.  It has no payload data.\n\n\nauthInfo\n\uf0c1\n\n\nSent by the server only in response to a \ngetAuthInfo\n request by the client.  The payload is the object \n{provider: \nstring\n, loggedIn: \nboolean\n, email: \nstring\n}\n where \nprovider\n and \nloggedIn\n\nare always set and \nemail\n is only set if the user has an email address.\n\n\nloadInteractive\n\uf0c1\n\n\nDEPRECATED\n The \ninitInteractive\n message includes the state, and should be used to get the state instead.\n\n\nSent by the server at startup after the LARA server is queried about the interactive's state and \nonly\n if the interactive has state.  The payload for the message is a arbitrary serialized object\npreviously set by the \ninteractiveState\n message.\n\n\ninitInteractive\n\uf0c1\n\n\nSent by the server at startup after the LARA server is queried about the interactive's state.  This message will always be sent, even if there is an error querying the server about the interactive state.\n\n\nSee the \ninitInteractive section in Implementing Interactive\n for details.\n\n\nglobal-iframe-saver.coffee Messages\n\uf0c1\n\n\ninteractiveStateGlobal\n\uf0c1\n\n\nSent by the client to the server and sets the global state that should be shared with all the interactives embedded in the current activity for the current student.  The payload for the message is\nan arbitrary serializable object. The global state is saved in database as text (stringified JSON) and LARA does not care about its content.\n\n\nOnce this message is received, the server immediately posts \nloadInteractiveGlobal\n to all interactives on the same page (except from the sender of the original save message).\n\n\nloadInteractiveGlobal\n\uf0c1\n\n\nSent by the server to all interactives on the current page (for current activity and student).  The payload for the message is an arbitrary serialized object.  It's interactive responsibility to interpret this message and load (or not) the given state.\n\n\nThis message is sent by the server when:\n\n\n\n\nThe \ninteractiveStateGlobal\n message is received by the server\n\n\nThe activity page is loaded \nand\n the global interactive state is available in LARA activity run (so only if \ninteractiveStateGlobal\n has been received earlier)\n\n\n\n\nlogger.js Messages\n\uf0c1\n\n\nlog\n\uf0c1\n\n\nThis message proxies communication from the interactive \u2192 LARA \u2192 Logging server.  There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone:\n\n\nphone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2})\n\n\n\n\nLARA listens to these events only when logging is enabled (they will be ignored otherwise). When a \nlog\n message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).", 
            "title": "LARA Interactive API"
        }, 
        {
            "location": "/#lara-interactive-api", 
            "text": "Table of contents:    LARA Interactive API  Startup and Initialization  iframe-saver.coffee Messages  getExtendedSupport  extendedSupport  getLearnerUrl  setLearnerUrl  getInteractiveState  interactiveState  getAuthInfo  authInfo  loadInteractive  initInteractive    global-iframe-saver.coffee Messages  interactiveStateGlobal  loadInteractiveGlobal    logger.js Messages  log", 
            "title": "LARA Interactive API"
        }, 
        {
            "location": "/#startup-and-initialization", 
            "text": "LARA interactive iframes communicate by using  iFramePhone  through three scripts loaded by the server in the browser:   iframe-saver.coffee , global-iframe-saver.coffee  and logger.js .  The LARA logging service also uses iFramePhones  RPC endpoint  to log events from the interactives.  The iframe-saver.coffee script first listens for the iFramePhone to connect and registers the message handlers documented below, then sends separate  getExtendedSupport  and  getLearnerUrl \nrequests to the client and finally calls back to the LARA server to get the current interactive state.  If there is existing interactive state the client will receive a  loadInteractive  message with the current interactive state as the parameter to the message.  However if no previous interactive state is found on the server the client will  not  receive a callback.  To allow interactives to have a\nconsistent startup a new message was added,  initInteractive  (documented below), which is always sent to the client after the server is queried for the interactive state by iframe-saver.coffee.  The global-iframe-saver.coffee script sets up a listener for the  interactiveStateGlobal  message and sends one message:  loadInteractiveGlobal .  The logger.js sets up a listener for the  log  message.  Since the three scripts above and the interactive's code are both running in the browser we will use the term server to mean the code in scripts interfacing with LARA above and client to be the interactive.", 
            "title": "Startup and Initialization"
        }, 
        {
            "location": "/#iframe-savercoffee-messages", 
            "text": "The client-side API can be split into two parts: messages initiated by the server to inform the client or request data back from the client and those initiated by the client to inform the server or request data back from the server.  Some of the messages from the client can be both responses to the server when it queries for information and requests to the server to set that information.", 
            "title": "iframe-saver.coffee Messages"
        }, 
        {
            "location": "/#getextendedsupport", 
            "text": "Sent automatically by the server at startup to query the client about their  extendedSupport  status.  This is the first message the client will receive and is sent before the call is made to\nthe server to get the interactive state.  It has no payload data.", 
            "title": "getExtendedSupport"
        }, 
        {
            "location": "/#extendedsupport", 
            "text": "Can be thought of as  setExtendedSupport . Sent by the client either in response to receiving a  getExtendedSupport  message or can be initiated by the client.  The payload for the message is an object with the following structure:  {reset:  boolean } .  If  reset  is true, we will allow the user to 'reset' the interactive via the  delete  button in the LARA runtime.", 
            "title": "extendedSupport"
        }, 
        {
            "location": "/#getlearnerurl", 
            "text": "DEPRECATED  instead you should use the messages that save and load interactive state:  initInteractive ,  getInteractiveState ,  interactiveState  Sent automatically by the server at startup to query the client about their learner url (the client responds via  setLearnerUrl ).  This is the second message the client will receive and is sent before the call is made to the server to get the interactive state.  It has no payload data.", 
            "title": "getLearnerUrl"
        }, 
        {
            "location": "/#setlearnerurl", 
            "text": "DEPRECATED  instead you should use the messages that save and load interactive state:  initInteractive ,  getInteractiveState ,  interactiveState  Sent by the client either in response to receiving a  getLearnerUrl  message or can be initiated by the client. The payload for the message is the string that denotes exact URL for the current student.", 
            "title": "setLearnerUrl"
        }, 
        {
            "location": "/#getinteractivestate", 
            "text": "Sent automatically by the server every 5 seconds to query the client about their interactive state. It has no payload data.  This is also sent by LARA before changing pages.  The client must respond with  initInteractive .  IMPORTANT  If the client does not respond with the  interactiveState  message then LARA will not change pages.", 
            "title": "getInteractiveState"
        }, 
        {
            "location": "/#interactivestate", 
            "text": "Can be thought of as  setInteractiveState . Sent by the client either in response to receiving a  getInteractiveState  message or can be initiated by the client.  The payload for the message is an arbitrary serializable object that will be stored by the LARA server.", 
            "title": "interactiveState"
        }, 
        {
            "location": "/#getauthinfo", 
            "text": "Sent by the client to the server to request the current users authentication information.  It has no payload data.", 
            "title": "getAuthInfo"
        }, 
        {
            "location": "/#authinfo", 
            "text": "Sent by the server only in response to a  getAuthInfo  request by the client.  The payload is the object  {provider:  string , loggedIn:  boolean , email:  string }  where  provider  and  loggedIn \nare always set and  email  is only set if the user has an email address.", 
            "title": "authInfo"
        }, 
        {
            "location": "/#loadinteractive", 
            "text": "DEPRECATED  The  initInteractive  message includes the state, and should be used to get the state instead.  Sent by the server at startup after the LARA server is queried about the interactive's state and  only  if the interactive has state.  The payload for the message is a arbitrary serialized object\npreviously set by the  interactiveState  message.", 
            "title": "loadInteractive"
        }, 
        {
            "location": "/#initinteractive", 
            "text": "Sent by the server at startup after the LARA server is queried about the interactive's state.  This message will always be sent, even if there is an error querying the server about the interactive state.  See the  initInteractive section in Implementing Interactive  for details.", 
            "title": "initInteractive"
        }, 
        {
            "location": "/#global-iframe-savercoffee-messages", 
            "text": "", 
            "title": "global-iframe-saver.coffee Messages"
        }, 
        {
            "location": "/#interactivestateglobal", 
            "text": "Sent by the client to the server and sets the global state that should be shared with all the interactives embedded in the current activity for the current student.  The payload for the message is\nan arbitrary serializable object. The global state is saved in database as text (stringified JSON) and LARA does not care about its content.  Once this message is received, the server immediately posts  loadInteractiveGlobal  to all interactives on the same page (except from the sender of the original save message).", 
            "title": "interactiveStateGlobal"
        }, 
        {
            "location": "/#loadinteractiveglobal", 
            "text": "Sent by the server to all interactives on the current page (for current activity and student).  The payload for the message is an arbitrary serialized object.  It's interactive responsibility to interpret this message and load (or not) the given state.  This message is sent by the server when:   The  interactiveStateGlobal  message is received by the server  The activity page is loaded  and  the global interactive state is available in LARA activity run (so only if  interactiveStateGlobal  has been received earlier)", 
            "title": "loadInteractiveGlobal"
        }, 
        {
            "location": "/#loggerjs-messages", 
            "text": "", 
            "title": "logger.js Messages"
        }, 
        {
            "location": "/#log", 
            "text": "This message proxies communication from the interactive \u2192 LARA \u2192 Logging server.  There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone:  phone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2})  LARA listens to these events only when logging is enabled (they will be ignored otherwise). When a  log  message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).", 
            "title": "log"
        }, 
        {
            "location": "/shutterbug/", 
            "text": "Shutterbug API\n\uf0c1\n\n\nShutterbug\n is used widely in Lab and in LARA, it uses \npostMessage\n to request child iFrames HTML content for snapshotting.\n\n\nThe basic PostMessage API Calls that are used in the shutterbug javascript project are \ndocumented in the github repo\n\n\nShutterbug Messages\n\uf0c1\n\n\nhtmlFragRequest\n\uf0c1\n\n\nParent asks iframes about their content:\n\n\n var message  = {\n   type:        'htmlFragRequest',\n   id:          id,       // Shutterbug ID\n   iframeReqId: iframeId, // position of iframe in dom\n   iframeReqTimeout: this.iframeReqTimeout * 0.6\n };\n window.postMessage(JSON.stringify(message), \n*\n);\n\n\n\n\nAnd an Iframe sends its content back:\n\n\nvar response = {\n  type:        'htmlFragResponse',\n  value:       html,\n  iframeReqId: iframeReqId, // counter, from request\n  id:          id           // sender_id from request\n};\nsource.postMessage(JSON.stringify(response), \n*\n);", 
            "title": "Shutterbug API"
        }, 
        {
            "location": "/shutterbug/#shutterbug-api", 
            "text": "Shutterbug  is used widely in Lab and in LARA, it uses  postMessage  to request child iFrames HTML content for snapshotting.  The basic PostMessage API Calls that are used in the shutterbug javascript project are  documented in the github repo", 
            "title": "Shutterbug API"
        }, 
        {
            "location": "/shutterbug/#shutterbug-messages", 
            "text": "", 
            "title": "Shutterbug Messages"
        }, 
        {
            "location": "/shutterbug/#htmlfragrequest", 
            "text": "Parent asks iframes about their content:   var message  = {\n   type:        'htmlFragRequest',\n   id:          id,       // Shutterbug ID\n   iframeReqId: iframeId, // position of iframe in dom\n   iframeReqTimeout: this.iframeReqTimeout * 0.6\n };\n window.postMessage(JSON.stringify(message),  * );  And an Iframe sends its content back:  var response = {\n  type:        'htmlFragResponse',\n  value:       html,\n  iframeReqId: iframeReqId, // counter, from request\n  id:          id           // sender_id from request\n};\nsource.postMessage(JSON.stringify(response),  * );", 
            "title": "htmlFragRequest"
        }, 
        {
            "location": "/using-iframe-phone/", 
            "text": "Using iFramePhone\n\uf0c1\n\n\nAs mentioned \niFramePhone\n is the service which LARA uses for much of its iFrame communication.   It is also used by Lab Interactives internally. Most of the Lab messages are ignored by LARA.\n\n\nHere for reference is what the implementation looks like. Taken from the \niFramePhone Readme\n:\n\n\nParent Setup\n\uf0c1\n\n\nvar phone = new iframePhone.ParentEndpoint(iframeElement, function () {\n  console.log(\nconnection with iframe established\n);\n});\nphone.post('testMessage', 'abc');\nphone.addListener('response', function (content) {\n  console.log(\nparent received response: \n + content);\n});\n\n\n\n\nIframe (child) Setup\n\uf0c1\n\n\nvar phone = iframePhone.getIFrameEndpoint();\nphone.addListener('testMessage', function (content) {\n  console.log(\niframe received message: \n + content);\n  phone.post('response', 'got it');\n});\n// IMPORTANT:\n// Initialize connection after all message listeners are added!\nphone.initialize();\n\n\n\n\nHello Messages\n\uf0c1\n\n\niFramePhone uses a \nhello\n messages to start communication with a specified origin. These messages get sent using the PostMessage API and look like this:\n\n\nvar message = {\n  type: \nhello\n,\n  origin: \nhttps://lab.concord.org\n\n};\n\n\n\n\nOther Messages\n\uf0c1\n\n\nSubsequent messages follow a similar pattern, specifiying \ntype\n which helps determine which listeners to notify:\n\n\nvar message = {\n  type:\nmodelLoaded\n,\n  \u2026\n};\n\n\n\n\nMessage Posting Implementation\n\uf0c1\n\n\nThe post messages looks like this as they are being sent out through iFramePhone. You don't need to worry about this; it is here for reference.\n\n\nmessage = {\n  type: \ngetLearnerUrl\n,\n  origin: \nhttp://localhost:3000\n,\n  content: {} // something specific to 'type'\n};\nWindow.postMessage(JSON.stringify(message), targetOrigin);", 
            "title": "Using iFramePhone"
        }, 
        {
            "location": "/using-iframe-phone/#using-iframephone", 
            "text": "As mentioned  iFramePhone  is the service which LARA uses for much of its iFrame communication.   It is also used by Lab Interactives internally. Most of the Lab messages are ignored by LARA.  Here for reference is what the implementation looks like. Taken from the  iFramePhone Readme :", 
            "title": "Using iFramePhone"
        }, 
        {
            "location": "/using-iframe-phone/#parent-setup", 
            "text": "var phone = new iframePhone.ParentEndpoint(iframeElement, function () {\n  console.log( connection with iframe established );\n});\nphone.post('testMessage', 'abc');\nphone.addListener('response', function (content) {\n  console.log( parent received response:   + content);\n});", 
            "title": "Parent Setup"
        }, 
        {
            "location": "/using-iframe-phone/#iframe-child-setup", 
            "text": "var phone = iframePhone.getIFrameEndpoint();\nphone.addListener('testMessage', function (content) {\n  console.log( iframe received message:   + content);\n  phone.post('response', 'got it');\n});\n// IMPORTANT:\n// Initialize connection after all message listeners are added!\nphone.initialize();", 
            "title": "Iframe (child) Setup"
        }, 
        {
            "location": "/using-iframe-phone/#hello-messages", 
            "text": "iFramePhone uses a  hello  messages to start communication with a specified origin. These messages get sent using the PostMessage API and look like this:  var message = {\n  type:  hello ,\n  origin:  https://lab.concord.org \n};", 
            "title": "Hello Messages"
        }, 
        {
            "location": "/using-iframe-phone/#other-messages", 
            "text": "Subsequent messages follow a similar pattern, specifiying  type  which helps determine which listeners to notify:  var message = {\n  type: modelLoaded ,\n  \u2026\n};", 
            "title": "Other Messages"
        }, 
        {
            "location": "/using-iframe-phone/#message-posting-implementation", 
            "text": "The post messages looks like this as they are being sent out through iFramePhone. You don't need to worry about this; it is here for reference.  message = {\n  type:  getLearnerUrl ,\n  origin:  http://localhost:3000 ,\n  content: {} // something specific to 'type'\n};\nWindow.postMessage(JSON.stringify(message), targetOrigin);", 
            "title": "Message Posting Implementation"
        }, 
        {
            "location": "/safari-cookies-redirects/", 
            "text": "Safari / IE, cookies and iframe redirects\n\uf0c1\n\n\nWhile recently debugging a weird authentication failure in an app that is regularly embedded within an iframe, I discovered some unexpected behavior in Safari and IE with respect to how it handles cookies for the sites within the iframe.\n\n\nThe TL;DR is this: \nCookies will not be sent to the destination site of a 302 redirect\n (the destination defined in the HTTP Location header), regardless of whether or not you've previously visited that site (unless the site is within the same main domain as the redirecting site).\n\n\nIn Safari, most of this behavior is due to the recent change of default settings. Under \nPrivacy\n -\n \nCookies and website data\n, the setting changed from \nAllow from websites I visit\n to \nAllow from current website only\n.\n\n\nThere doesn't seem to be a setting around this behavior in IE.\n\n\nExample\n\uf0c1\n\n\nOur app uses OAuth2 to sign in via a different app. The sign in process involves several redirects (these aren't the actual domains/paths, but roughly the same steps):\n\n\nRequest                            Response\nGET:  https://app.com/login        302: https://sso.com/sso/login\nGET:  https://sso.com/sso/login    200\nPOST: https://sso.com/sso/login    302: https://app.com/sso/callback\nGET:  https://app.com/sso/callback 302: https://app.com/\n\n\n\nThis all works fine in Safari when accessing app.com in a top-level window. However, this all breaks down when running within an iframe.\n\n\nIt turns out that Safari will \nnot\n send cookies to \nsso.com\n in the 2nd request, and additionally will \nnot\n send cookies to \napp.com\n in the 4th request. The whole sign in process relies on maintaining consistent sessions, so when no cookies are sent, the sign in doesn't take, and the user is left on app.com in a logged out state.\n\n\nWorkarounds\n\uf0c1\n\n\n\n\n\n\nI haven't been able to test this, but supposedly you can work around this cookie behavior by rendering a page which redirects via the page content, rather than redirecting via a 302 response with a \nLocation\n header.\n\n\nhtml\n\n  \nhead\n\n    \ntitle\nSign In\n/title\n\n    \nmeta http-equiv=\"refresh\" content=\"0;URL='https://sso.com/sso/login'\" /\n\n  \n/head\n\n  \nbody\n\n    \np\nThis page has moved to a \na href=\"https://sso.com/sso/login\"\nnew location\n/a\n.\n/p\n\n  \n/body\n\n\n/html\n\n\n\n\nHowever, you'll have to take care that the request to the other site is essentially the same (Referrer, Origin, etc all present the same info).\n\n\n\n\n\n\nAlso, Safari's definition of \ncurrent website\n is a bit loose when it comes to the hostname. foo.app.com is considered the same site as bar.app.com. We were fortunate enough to be able to use this tactic to bring our app into the same \"site\" as the sso provider, but that's not usually possible when working with a 3rd-party provider.\n\n\n\n\n\n\nIf your redirecting code makes a full round-trip, another option is to do all of your redirecting in a separate window. Use Javascript to open a window, and then monitor its url. Once the url is back to the location you're expecting, close the window and reload the iframe page.\n\n\nThe library is here:\n\n\n// A wrapper around having an external link pop up in its own window, and then automatically monitoring it\n// and closing it when it returns to the same domain as the current page.\n\nwindow.inIframe = function() {\n  try {\n      return window.self !== window.top;\n  } catch (e) {\n      return true;\n  }\n};\n\nwindow.AutomaticallyClosingPopupLink = {\n  configure: function($link, directUrl, popupUrl, afterCloseUrl) {\n    var onClick = function() {\n      if (window.inIframe()) {\n        // Pop up the url in a new window\n        // Monitor it and close it when done\n        // Redirect the current page when closed\n        this._popupWindow($link.id, popupUrl, afterCloseUrl);\n      } else {\n        window.location.href = directUrl;\n      }\n    }.bind(this);\n    $link.on('click', onClick);\n  },\n\n  // This code was adapted from CODAP's implementation of a similar feature\n  _popupWindow: function(id, popupUrl, afterCloseUrl) {\n    var width  = 800,\n        height = 480,\n        position = this._computeScreenLocation(width, height),\n        windowFeatures = [\n          'width=' + width,\n          'height=' + height,\n          'top=' + position.top || 200,\n          'left=' + position.left || 200,\n          'dependent=yes',\n          'resizable=no',\n          'location=no',\n          'dialog=yes',\n          'menubar=no'\n        ],\n        exceptionCount = 0,\n        panel = window.open(popupUrl, id, windowFeatures.join()),\n        checkPanelHref = function() {\n          try {\n            /* This is a bit of a hack. Accessing a popup's location throws a security exception\n             * when the url is cross-origin. Therefore, 1) this should only be used with urls that are         cross-origin, and 2) the url\n             * should eventually return to a non-cross-origin url at the time the window should be closed.\n             */\n            var href = panel.location.href; // This will throw an exception if the url is still cross-origin.\n\n            // If exceptionCount is not 0, then we hit an external url and came back. Assume that we're done.\n            // If it's still 0, then keep waiting for the url to change to something external and change back.\n            if (exceptionCount \n 0) {\n              window.clearInterval(timer);\n              panel.close();\n              if (afterCloseUrl) {\n                document.location = afterCloseUrl;\n              } else {\n                document.location.reload();\n              }\n            }\n          } catch(e) {\n            exceptionCount++;\n          }\n        },\n        timer = window.setInterval(checkPanelHref, 200);\n  },\n\n  _computeScreenLocation: function(w, h) {\n    // Fixes dual-screen position                         Most browsers      Firefox\n    var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;\n    var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;\n\n    var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ?         document.documentElement.clientWidth : screen.width;\n    var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\n    var left = ((width / 2) - (w / 2)) + dualScreenLeft;\n    var top = ((height / 2) - (h / 2)) + dualScreenTop;\n    return {left: left, top: top};\n  }\n};\n\n\n\nAnd it's used via this code in the page:\n\n\njQuery(function() {\n  var button = jQuery('#login_button'),\n      path = '/login',\n      popup = '/popupLogin',\n      redirect = '/';\n\n  window.AutomaticallyClosingPopupLink.configure(button, path, popup, redirect);\n});", 
            "title": "Safari / IE, cookies and iframe redirects"
        }, 
        {
            "location": "/safari-cookies-redirects/#safari-ie-cookies-and-iframe-redirects", 
            "text": "While recently debugging a weird authentication failure in an app that is regularly embedded within an iframe, I discovered some unexpected behavior in Safari and IE with respect to how it handles cookies for the sites within the iframe.  The TL;DR is this:  Cookies will not be sent to the destination site of a 302 redirect  (the destination defined in the HTTP Location header), regardless of whether or not you've previously visited that site (unless the site is within the same main domain as the redirecting site).  In Safari, most of this behavior is due to the recent change of default settings. Under  Privacy  -   Cookies and website data , the setting changed from  Allow from websites I visit  to  Allow from current website only .  There doesn't seem to be a setting around this behavior in IE.", 
            "title": "Safari / IE, cookies and iframe redirects"
        }, 
        {
            "location": "/safari-cookies-redirects/#example", 
            "text": "Our app uses OAuth2 to sign in via a different app. The sign in process involves several redirects (these aren't the actual domains/paths, but roughly the same steps):  Request                            Response\nGET:  https://app.com/login        302: https://sso.com/sso/login\nGET:  https://sso.com/sso/login    200\nPOST: https://sso.com/sso/login    302: https://app.com/sso/callback\nGET:  https://app.com/sso/callback 302: https://app.com/  This all works fine in Safari when accessing app.com in a top-level window. However, this all breaks down when running within an iframe.  It turns out that Safari will  not  send cookies to  sso.com  in the 2nd request, and additionally will  not  send cookies to  app.com  in the 4th request. The whole sign in process relies on maintaining consistent sessions, so when no cookies are sent, the sign in doesn't take, and the user is left on app.com in a logged out state.", 
            "title": "Example"
        }, 
        {
            "location": "/safari-cookies-redirects/#workarounds", 
            "text": "I haven't been able to test this, but supposedly you can work around this cookie behavior by rendering a page which redirects via the page content, rather than redirecting via a 302 response with a  Location  header.  html \n   head \n     title Sign In /title \n     meta http-equiv=\"refresh\" content=\"0;URL='https://sso.com/sso/login'\" / \n   /head \n   body \n     p This page has moved to a  a href=\"https://sso.com/sso/login\" new location /a . /p \n   /body  /html   However, you'll have to take care that the request to the other site is essentially the same (Referrer, Origin, etc all present the same info).    Also, Safari's definition of  current website  is a bit loose when it comes to the hostname. foo.app.com is considered the same site as bar.app.com. We were fortunate enough to be able to use this tactic to bring our app into the same \"site\" as the sso provider, but that's not usually possible when working with a 3rd-party provider.    If your redirecting code makes a full round-trip, another option is to do all of your redirecting in a separate window. Use Javascript to open a window, and then monitor its url. Once the url is back to the location you're expecting, close the window and reload the iframe page.  The library is here:  // A wrapper around having an external link pop up in its own window, and then automatically monitoring it\n// and closing it when it returns to the same domain as the current page.\n\nwindow.inIframe = function() {\n  try {\n      return window.self !== window.top;\n  } catch (e) {\n      return true;\n  }\n};\n\nwindow.AutomaticallyClosingPopupLink = {\n  configure: function($link, directUrl, popupUrl, afterCloseUrl) {\n    var onClick = function() {\n      if (window.inIframe()) {\n        // Pop up the url in a new window\n        // Monitor it and close it when done\n        // Redirect the current page when closed\n        this._popupWindow($link.id, popupUrl, afterCloseUrl);\n      } else {\n        window.location.href = directUrl;\n      }\n    }.bind(this);\n    $link.on('click', onClick);\n  },\n\n  // This code was adapted from CODAP's implementation of a similar feature\n  _popupWindow: function(id, popupUrl, afterCloseUrl) {\n    var width  = 800,\n        height = 480,\n        position = this._computeScreenLocation(width, height),\n        windowFeatures = [\n          'width=' + width,\n          'height=' + height,\n          'top=' + position.top || 200,\n          'left=' + position.left || 200,\n          'dependent=yes',\n          'resizable=no',\n          'location=no',\n          'dialog=yes',\n          'menubar=no'\n        ],\n        exceptionCount = 0,\n        panel = window.open(popupUrl, id, windowFeatures.join()),\n        checkPanelHref = function() {\n          try {\n            /* This is a bit of a hack. Accessing a popup's location throws a security exception\n             * when the url is cross-origin. Therefore, 1) this should only be used with urls that are         cross-origin, and 2) the url\n             * should eventually return to a non-cross-origin url at the time the window should be closed.\n             */\n            var href = panel.location.href; // This will throw an exception if the url is still cross-origin.\n\n            // If exceptionCount is not 0, then we hit an external url and came back. Assume that we're done.\n            // If it's still 0, then keep waiting for the url to change to something external and change back.\n            if (exceptionCount   0) {\n              window.clearInterval(timer);\n              panel.close();\n              if (afterCloseUrl) {\n                document.location = afterCloseUrl;\n              } else {\n                document.location.reload();\n              }\n            }\n          } catch(e) {\n            exceptionCount++;\n          }\n        },\n        timer = window.setInterval(checkPanelHref, 200);\n  },\n\n  _computeScreenLocation: function(w, h) {\n    // Fixes dual-screen position                         Most browsers      Firefox\n    var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left;\n    var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top;\n\n    var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ?         document.documentElement.clientWidth : screen.width;\n    var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height;\n\n    var left = ((width / 2) - (w / 2)) + dualScreenLeft;\n    var top = ((height / 2) - (h / 2)) + dualScreenTop;\n    return {left: left, top: top};\n  }\n};  And it's used via this code in the page:  jQuery(function() {\n  var button = jQuery('#login_button'),\n      path = '/login',\n      popup = '/popupLogin',\n      redirect = '/';\n\n  window.AutomaticallyClosingPopupLink.configure(button, path, popup, redirect);\n});", 
            "title": "Workarounds"
        }, 
        {
            "location": "/about-mkdocs/", 
            "text": "Welcome to MkDocs\n\uf0c1\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nRequirements:\n\uf0c1\n\n\nYou must install mkdocs to build the documentation. \npip install mkdocs\n\n\nBuild\n\uf0c1\n\n\nWhen you have \nmkdocs\n installed, \nbuild.sh\n will invoke \nmkdocs\n to build the project documentation as part of the gh-pages.\n\n\nOther Commands\n\uf0c1\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\uf0c1\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "About the documentation generator"
        }, 
        {
            "location": "/about-mkdocs/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/about-mkdocs/#requirements", 
            "text": "You must install mkdocs to build the documentation.  pip install mkdocs", 
            "title": "Requirements:"
        }, 
        {
            "location": "/about-mkdocs/#build", 
            "text": "When you have  mkdocs  installed,  build.sh  will invoke  mkdocs  to build the project documentation as part of the gh-pages.", 
            "title": "Build"
        }, 
        {
            "location": "/about-mkdocs/#other-commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Other Commands"
        }, 
        {
            "location": "/about-mkdocs/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }
    ]
}