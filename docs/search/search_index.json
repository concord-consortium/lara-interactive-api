{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LARA Interactive API \uf0c1 Table of contents: LARA Interactive API Startup and Initialization iframe-saver.coffee Messages getExtendedSupport extendedSupport getLearnerUrl setLearnerUrl getInteractiveState interactiveState getAuthInfo authInfo loadInteractive initInteractive navigation global-iframe-saver.coffee Messages interactiveStateGlobal loadInteractiveGlobal logger.js Messages log Startup and Initialization \uf0c1 LARA interactive iframes communicate by using iFramePhone through three scripts loaded by the server in the browser: iframe-saver.coffee , global-iframe-saver.coffee and logger.js . The LARA logging service also uses iFramePhones RPC endpoint to log events from the interactives. The iframe-saver.coffee script first listens for the iFramePhone to connect and registers the message handlers documented below, then sends separate getExtendedSupport and getLearnerUrl requests to the client and finally calls back to the LARA server to get the current interactive state. If there is existing interactive state the client will receive a loadInteractive message with the current interactive state as the parameter to the message. However if no previous interactive state is found on the server the client will not receive a callback. To allow interactives to have a consistent startup a new message was added, initInteractive (documented below), which is always sent to the client after the server is queried for the interactive state by iframe-saver.coffee. The global-iframe-saver.coffee script sets up a listener for the interactiveStateGlobal message and sends one message: loadInteractiveGlobal . The logger.js sets up a listener for the log message. Since the three scripts above and the interactive's code are both running in the browser we will use the term server to mean the code in scripts interfacing with LARA above and client to be the interactive. iframe-saver.coffee Messages \uf0c1 The client-side API can be split into two parts: messages initiated by the server to inform the client or request data back from the client and those initiated by the client to inform the server or request data back from the server. Some of the messages from the client can be both responses to the server when it queries for information and requests to the server to set that information. getExtendedSupport \uf0c1 Sent automatically by the server at startup to query the client about their extendedSupport status. This is the first message the client will receive and is sent before the call is made to the server to get the interactive state. It has no payload data. extendedSupport \uf0c1 Can be thought of as setExtendedSupport . Sent by the client either in response to receiving a getExtendedSupport message or can be initiated by the client. The payload for the message is an object with the following structure: {reset: <boolean>} . If reset is true, we will allow the user to 'reset' the interactive via the delete button in the LARA runtime. getLearnerUrl \uf0c1 DEPRECATED instead you should use the messages that save and load interactive state: initInteractive , getInteractiveState , interactiveState Sent automatically by the server at startup to query the client about their learner url (the client responds via setLearnerUrl ). This is the second message the client will receive and is sent before the call is made to the server to get the interactive state. It has no payload data. setLearnerUrl \uf0c1 DEPRECATED instead you should use the messages that save and load interactive state: initInteractive , getInteractiveState , interactiveState Sent by the client either in response to receiving a getLearnerUrl message or can be initiated by the client. The payload for the message is the string that denotes exact URL for the current student. getInteractiveState \uf0c1 Sent automatically by the server every 5 seconds to query the client about their interactive state. It has no payload data. This is also sent by LARA before changing pages. The client must respond with initInteractive . IMPORTANT If the client does not respond with the interactiveState message then LARA will not change pages. interactiveState \uf0c1 Can be thought of as setInteractiveState . Sent by the client either in response to receiving a getInteractiveState message or can be initiated by the client. The payload for the message is an arbitrary serializable object that will be stored by the LARA server. getAuthInfo \uf0c1 Sent by the client to the server to request the current users authentication information. It has no payload data. authInfo \uf0c1 Sent by the server only in response to a getAuthInfo request by the client. The payload is the object {provider: <string>, loggedIn: <boolean>, email: <string>} where provider and loggedIn are always set and email is only set if the user has an email address. loadInteractive \uf0c1 DEPRECATED The initInteractive message includes the state, and should be used to get the state instead. Sent by the server at startup after the LARA server is queried about the interactive's state and only if the interactive has state. The payload for the message is a arbitrary serialized object previously set by the interactiveState message. initInteractive \uf0c1 Sent by the server at startup after the LARA server is queried about the interactive's state. This message will always be sent, even if there is an error querying the server about the interactive state. See the initInteractive section in Implementing Interactive for details. navigation \uf0c1 Sent by the client to enable/disable page navigation. The payload is the object {enableForwardNav: <boolean>, message: string} where message is an optional message shown in an jQuery alert box when the forward navigation is clicked when disabled. global-iframe-saver.coffee Messages \uf0c1 interactiveStateGlobal \uf0c1 Sent by the client to the server and sets the global state that should be shared with all the interactives embedded in the current activity for the current student. The payload for the message is an arbitrary serializable object. The global state is saved in database as text (stringified JSON) and LARA does not care about its content. Once this message is received, the server immediately posts loadInteractiveGlobal to all interactives on the same page (except from the sender of the original save message). loadInteractiveGlobal \uf0c1 Sent by the server to all interactives on the current page (for current activity and student). The payload for the message is an arbitrary serialized object. It's interactive responsibility to interpret this message and load (or not) the given state. This message is sent by the server when: The interactiveStateGlobal message is received by the server The activity page is loaded and the global interactive state is available in LARA activity run (so only if interactiveStateGlobal has been received earlier) logger.js Messages \uf0c1 log \uf0c1 This message proxies communication from the interactive \u2192 LARA \u2192 Logging server. There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone: phone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2}) LARA listens to these events only when logging is enabled (they will be ignored otherwise). When a log message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).","title":"LARA Interactive API"},{"location":"#lara-interactive-api","text":"Table of contents: LARA Interactive API Startup and Initialization iframe-saver.coffee Messages getExtendedSupport extendedSupport getLearnerUrl setLearnerUrl getInteractiveState interactiveState getAuthInfo authInfo loadInteractive initInteractive navigation global-iframe-saver.coffee Messages interactiveStateGlobal loadInteractiveGlobal logger.js Messages log","title":"LARA Interactive API"},{"location":"#startup-and-initialization","text":"LARA interactive iframes communicate by using iFramePhone through three scripts loaded by the server in the browser: iframe-saver.coffee , global-iframe-saver.coffee and logger.js . The LARA logging service also uses iFramePhones RPC endpoint to log events from the interactives. The iframe-saver.coffee script first listens for the iFramePhone to connect and registers the message handlers documented below, then sends separate getExtendedSupport and getLearnerUrl requests to the client and finally calls back to the LARA server to get the current interactive state. If there is existing interactive state the client will receive a loadInteractive message with the current interactive state as the parameter to the message. However if no previous interactive state is found on the server the client will not receive a callback. To allow interactives to have a consistent startup a new message was added, initInteractive (documented below), which is always sent to the client after the server is queried for the interactive state by iframe-saver.coffee. The global-iframe-saver.coffee script sets up a listener for the interactiveStateGlobal message and sends one message: loadInteractiveGlobal . The logger.js sets up a listener for the log message. Since the three scripts above and the interactive's code are both running in the browser we will use the term server to mean the code in scripts interfacing with LARA above and client to be the interactive.","title":"Startup and Initialization"},{"location":"#iframe-savercoffee-messages","text":"The client-side API can be split into two parts: messages initiated by the server to inform the client or request data back from the client and those initiated by the client to inform the server or request data back from the server. Some of the messages from the client can be both responses to the server when it queries for information and requests to the server to set that information.","title":"iframe-saver.coffee Messages"},{"location":"#getextendedsupport","text":"Sent automatically by the server at startup to query the client about their extendedSupport status. This is the first message the client will receive and is sent before the call is made to the server to get the interactive state. It has no payload data.","title":"getExtendedSupport"},{"location":"#extendedsupport","text":"Can be thought of as setExtendedSupport . Sent by the client either in response to receiving a getExtendedSupport message or can be initiated by the client. The payload for the message is an object with the following structure: {reset: <boolean>} . If reset is true, we will allow the user to 'reset' the interactive via the delete button in the LARA runtime.","title":"extendedSupport"},{"location":"#getlearnerurl","text":"DEPRECATED instead you should use the messages that save and load interactive state: initInteractive , getInteractiveState , interactiveState Sent automatically by the server at startup to query the client about their learner url (the client responds via setLearnerUrl ). This is the second message the client will receive and is sent before the call is made to the server to get the interactive state. It has no payload data.","title":"getLearnerUrl"},{"location":"#setlearnerurl","text":"DEPRECATED instead you should use the messages that save and load interactive state: initInteractive , getInteractiveState , interactiveState Sent by the client either in response to receiving a getLearnerUrl message or can be initiated by the client. The payload for the message is the string that denotes exact URL for the current student.","title":"setLearnerUrl"},{"location":"#getinteractivestate","text":"Sent automatically by the server every 5 seconds to query the client about their interactive state. It has no payload data. This is also sent by LARA before changing pages. The client must respond with initInteractive . IMPORTANT If the client does not respond with the interactiveState message then LARA will not change pages.","title":"getInteractiveState"},{"location":"#interactivestate","text":"Can be thought of as setInteractiveState . Sent by the client either in response to receiving a getInteractiveState message or can be initiated by the client. The payload for the message is an arbitrary serializable object that will be stored by the LARA server.","title":"interactiveState"},{"location":"#getauthinfo","text":"Sent by the client to the server to request the current users authentication information. It has no payload data.","title":"getAuthInfo"},{"location":"#authinfo","text":"Sent by the server only in response to a getAuthInfo request by the client. The payload is the object {provider: <string>, loggedIn: <boolean>, email: <string>} where provider and loggedIn are always set and email is only set if the user has an email address.","title":"authInfo"},{"location":"#loadinteractive","text":"DEPRECATED The initInteractive message includes the state, and should be used to get the state instead. Sent by the server at startup after the LARA server is queried about the interactive's state and only if the interactive has state. The payload for the message is a arbitrary serialized object previously set by the interactiveState message.","title":"loadInteractive"},{"location":"#initinteractive","text":"Sent by the server at startup after the LARA server is queried about the interactive's state. This message will always be sent, even if there is an error querying the server about the interactive state. See the initInteractive section in Implementing Interactive for details.","title":"initInteractive"},{"location":"#navigation","text":"Sent by the client to enable/disable page navigation. The payload is the object {enableForwardNav: <boolean>, message: string} where message is an optional message shown in an jQuery alert box when the forward navigation is clicked when disabled.","title":"navigation"},{"location":"#global-iframe-savercoffee-messages","text":"","title":"global-iframe-saver.coffee Messages"},{"location":"#interactivestateglobal","text":"Sent by the client to the server and sets the global state that should be shared with all the interactives embedded in the current activity for the current student. The payload for the message is an arbitrary serializable object. The global state is saved in database as text (stringified JSON) and LARA does not care about its content. Once this message is received, the server immediately posts loadInteractiveGlobal to all interactives on the same page (except from the sender of the original save message).","title":"interactiveStateGlobal"},{"location":"#loadinteractiveglobal","text":"Sent by the server to all interactives on the current page (for current activity and student). The payload for the message is an arbitrary serialized object. It's interactive responsibility to interpret this message and load (or not) the given state. This message is sent by the server when: The interactiveStateGlobal message is received by the server The activity page is loaded and the global interactive state is available in LARA activity run (so only if interactiveStateGlobal has been received earlier)","title":"loadInteractiveGlobal"},{"location":"#loggerjs-messages","text":"","title":"logger.js Messages"},{"location":"#log","text":"This message proxies communication from the interactive \u2192 LARA \u2192 Logging server. There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone: phone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2}) LARA listens to these events only when logging is enabled (they will be ignored otherwise). When a log message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).","title":"log"},{"location":"about-mkdocs/","text":"Welcome to MkDocs \uf0c1 For full documentation visit mkdocs.org . Requirements: \uf0c1 You must install mkdocs to build the documentation. pip install mkdocs Build \uf0c1 When you have mkdocs installed, build.sh will invoke mkdocs to build the project documentation as part of the gh-pages. Other Commands \uf0c1 mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout \uf0c1 mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"About the documentation generator"},{"location":"about-mkdocs/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"about-mkdocs/#requirements","text":"You must install mkdocs to build the documentation. pip install mkdocs","title":"Requirements:"},{"location":"about-mkdocs/#build","text":"When you have mkdocs installed, build.sh will invoke mkdocs to build the project documentation as part of the gh-pages.","title":"Build"},{"location":"about-mkdocs/#other-commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Other Commands"},{"location":"about-mkdocs/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"implementing-interactive/","text":"Implementing Interactive \uf0c1 LARA embeds interactives using iframe and provides LARA Interactive API. This API can be used e.g. to customize interactive, save state authored by teachers or save student progress. The whole communication between LARA and Interactive happens through iFramePhone which is a simple wrapper around postMessage API. Interactive which wants to use LARA Interactive API needs to use this library. Check its readme to see how to include it in your project (npm, RequireJS or via script tag). Once iframePhone library is available, Interactive needs to setup communication: iframe-phone setup \uf0c1 var phone = iframePhone.getIFrameEndpoint(); phone.addListener('initInteractive', function (data) { // handle initInteractive call }); phone.addListener('otherMessageType', function (data) { // handle otherMessageType call }); // more handlers here // IMPORTANT: Initialize connection after all message listeners are added! phone.initialize(); // Inform LARA about supported features. Some of them require that // (e.g. state authoring, student progress saving): phone.post('supportedFeatures', { apiVersion: 1, features: { someFeature: true otherFeature: true } }); Handling the initInteractive message \uf0c1 This is one of the most important messages sent by LARA. It provides most of the information stored by LARA. It tells the interactive what is the current API version, mode ( runtime , authoring or report ), authoredState (state defined by author), interactiveState (state based on student work) and so on. Interactive should add initInteractive handler that reads values stored in data Object / hash: phone.addListener('initInteractive', function (data) { // process data object, e.g.: initializeMode(data.mode); loadAuthoredState(data.authoredState); loadStudentWork(data.interactiveState); }); Data passed to initInteractive \uf0c1 error - null if everything is okay, error message otherwise (e.g. data fetching might fail). mode - \"authoring\" , \"runtime\" or \"report\" . Interactive can be displayed in one of those three modes, but it's up to interactive whether it supports authoring mode. Runtime is basic mode which is presented to students. Authoring mode can be used by authors to customize interactive. Report mode is used when embedding the interactive in a report. authoredState [optional] - JSON that has been saved by interactive earlier in authoring mode using authoredState message (described below in other section). If it's not defined, it would be falsy value (null or empty string). interactiveState [optional] - JSON that has been saved by interactive earlier in runtime mode using interactiveState message. More detail in Saving Student Progress section . Provided only in runtime mode. If it's not defined, it would be falsy value (null or empty string). globalInteractiveState [optional] - JSON that has been saved by any interactive in the same activity earlier in runtime mode using globalInteractiveState message . Provided only in runtime mode. If it's not defined, it would be falsy value (null or empty string). hasLinkedInteractive [optional] - boolean or undefined. If this is true then the author has linked this interactive to another interactive in the activity or sequence. This will be true even if the linked interactive has not saved state yet. linkedState [optional] - JSON that has been saved by the linked interactive. If no state has been saved this will be falsy. interactiveStateUrl [optional] - Fully qualified URL to access the interactive state externally. See Accessing Interactive State with HTTP for more information. collaboratorUrls [optional] - Fully qualified URL to access the interactive state of each collaborator working with the current student. These URLs can be used to save a copy of the work into each collaborator's interactive state. classInfoUrl - URL to request more information about the class of the student that is running the interactive. When run as a student in the portal this URL is of form: https://learn.staging.concord.org/api/v1/classes/[class_id] it provides information about the teachers and students of the class. As well as a class_hash that can be used to store info about the class in a external system (like Firebase). The URL is protected by cookie based authentication. withCredentials should be used to access it. TODO: what happens when the activity is run without a class? For example when it is run anonymously. interactive - The value of this is {id: [id of interactive in LARA], name: [name of interactive in LARA]} authInfo - The value of this is {provider: [domain of authentication provider], loggedIn: [whether the current user is logged in], email: [email address for the current user]} Interactive customization \uf0c1 If interactive wants to support customization, it should inform LARA about it using supportedFeatures message: phone.post('supportedFeatures', { apiVersion: 1, features: { authoredState: true // + other supported features } }); initInteractive message provides mode property. Interactive can display authoring interface when mode value is equal to \"authoring\" . Every customization made by author should be sent back to LARA using authoredState message: phone.post('authoredState', data); The authoredState data should be a JSON compatible object, that is the only requirement. Next time the interactive is loaded either in authoring or runtime mode, initInteractive will provide this state to the interactive in authoredState property. Note that it's recommended that authoredState should be sent to LARA immediately after every change. LARA provides its own \"Save\" button that would actually save this state to the DB and \"Reset\" which would set it back to null. Saving student progress \uf0c1 If interactive wants to support student progress saving, it should inform LARA about it using supportedFeatures message: phone.post('supportedFeatures', { apiVersion: 1, features: { interactiveState: true // + other supported features } }); Currently, LARA is not paying attention to this interactiveState supportedFeature, but it will do so in the future. When this interactive is added to a LARA page the author needs to check the \"save state\" checkbox. initInteractive provides mode property. \"runtime\" mode means that Interactive is viewed by student. Interactive can save student progress using interactiveState message: phone.post('interactiveState', data); Normally the interactiveState data should be a JSON compatible object, that is the only requirement. Next time the interactive is loaded in runtime mode, initInteractive will provide this state to the interactive in interactiveState property. LARA will send the interactive a getInteractiveState periodically: every 5 seconds on window focus iframe mouseout when the student tries to leave the page containing the interactive The interactive should add a listener for getInteractiveState . To be safe, remember to add the listener before calling phone.initialize(); . Here is an example listener: phone.addListener('getInteractiveState', function () { phone.post('interactiveState', interactiveState); }); IMPORTANT When the student tries to leave the page with the interactive, the interactive needs to respond with an interactiveState message. LARA will not changes pages until it receives this message. There is a special value \"nochange\" , that can be sent as the interactiveState data. This tells LARA the interactiveState has not changed since the last time. This is useful when responding to getInteractiveState Interactive aspectRatio \uf0c1 If interactive wants to tell LARA what aspect ratio use, it should inform LARA about it using supportedFeatures message: phone.post('supportedFeatures', { apiVersion: 1, features: { aspectRatio: 1.67 // + other supported features } }); The LARA author needs to select \"Default aspect ratio, or set by interactive\" in the interactive authoring dialog box, otherwise this setting will be ignored. More info about the interactive sizing can be found in the LARA Authoring User Manual . Custom learner URL \uf0c1 DEPRECATED This feature is related to student progress saving. Interactive can provide versioned URL to make sure that the given data format is always supported. Otherwise the interactive might be updated and not be able to open the old state format. This is deprecated because it causes more problems than it is worth. We have wanted to remove support for old versions of interactives, and we've had to remember to go through all of the interactive states and these learner urls. Also the concept of saving a URL that works in this maner is confusing. Sometimes the interactive is loaded with the authored URL sometimes it is loaded with the saved URL. So a set of students or testers might see different versions of what seems like it should be the same interactive. Instead of using this approach to handle old state, the interactive should handle migrating its own old state. If migrating its own state isn't practical then please work with the LARA developers to do a batch migration on the server. phone.post('setLearnerUrl', 'https://my.example.interactive/version/1'); Global interactive state \uf0c1 A few interactives can share one global state within a single LARA activity. E.g. you can let students work on the same model on different pages of the activity. Interactive can set global state using interactiveStateGlobal message: phone.post('interactiveStateGlobal', globalState); Once this message is received, the server immediately posts loadInteractiveGlobal to all interactives on the same page (except from the sender of the original save message). So, interactives can listen to this message: phone.addListener('loadInteraciveGlobal', function (globalState) { // Process global state, e.g.: loadState(globalState); }); If one of the interactives has sent interactiveStateGlobal message before another interactive is initialized then the global state will be provided in the initInteractive message. NOTE Another way to communicate between two interactives is with Linked Interactives . Logging \uf0c1 This message proxies communication from the interactive \u2192 LARA \u2192 Logging server. There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone: phone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2}}); LARA listens to these events only when logging is enabled (they will be ignored otherwise). When a log message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.). Auth info \uf0c1 Interactive can ask LARA about the current users authentication information using getAuthInfo message. It has no payload data: phone.post('getAuthInfo'); LARA responds using authInfo message: phone.addListener('authInfo', function (info) { // ... }); The payload is the object {provider: <string>, loggedIn: <boolean>, email: <string>} where provider and loggedIn are always set and email is only set if the user has an email address. getExtendedSupport \uf0c1 This is a message sent by LARA to the interactive. The interactive can respond with a extendedSupport message. The data of the extendedSupport only supports one property reset . The value of reset should be boolean. If the interactive sends reset: true then LARA will show a button below the interactive for clearing the interactive state and reloading the interactive. If reset: false then LARA will not show this button. By default LARA will show this button. NOTE this extended support message is out of date. It is the only way to hide the reset button, so it isn't deprecated. New options like this will be added to the supportedFeatures message described above. Linked interactives \uf0c1 Each interactive in LARA can be linked with one other interactive in the same activity or sequence. A LARA author edits the main interactive and can add a reference to the linked interactive. Currently this reference is with an interactive id, but that referencing mechanism could change and it should not effect how the interactives are implemented. When the main interactive is loaded it will be sent the initInteractive message just like normal. This message has 2 fields in related to linked interactives. The hasLinkedInteractive field will be set to true if the author has setup the linking. This will be true even if the learner hasn't done any work on the linked interactive yet. The linkedState field will contain the work the learner has done on the linked interactive. It will be falsy if the student hasn't done any work. An example use case is an activity where a student is incrementally building a diagram. In interactive 1 the student fills out part of the diagram and then in interactive 2 the student is asked to add more to the diagram. Interactive 2 can load in the state from the interactive 1 and display the diagram the student created before. Any new changes made can be saved separately into interactive 2's state. The state of interactive 1 will be preserved. The main interactive can use the hasLinkedInteractive field to tell the difference between being used independently in the activity or being linked to another interactive. In the diagram example above, if interactive 2 sees there is no linkedState, it should then check hasLinkedInteractive . In that case it could tell the student \"you should complete the previous diagram before starting this one\". If hasLinkedInteractive is falsy then the interactive knows it shouldn't show this message. Accessing Interactive State with HTTP \uf0c1 TODO","title":"Implementing Interactive"},{"location":"implementing-interactive/#implementing-interactive","text":"LARA embeds interactives using iframe and provides LARA Interactive API. This API can be used e.g. to customize interactive, save state authored by teachers or save student progress. The whole communication between LARA and Interactive happens through iFramePhone which is a simple wrapper around postMessage API. Interactive which wants to use LARA Interactive API needs to use this library. Check its readme to see how to include it in your project (npm, RequireJS or via script tag). Once iframePhone library is available, Interactive needs to setup communication:","title":"Implementing Interactive"},{"location":"implementing-interactive/#iframe-phone-setup","text":"var phone = iframePhone.getIFrameEndpoint(); phone.addListener('initInteractive', function (data) { // handle initInteractive call }); phone.addListener('otherMessageType', function (data) { // handle otherMessageType call }); // more handlers here // IMPORTANT: Initialize connection after all message listeners are added! phone.initialize(); // Inform LARA about supported features. Some of them require that // (e.g. state authoring, student progress saving): phone.post('supportedFeatures', { apiVersion: 1, features: { someFeature: true otherFeature: true } });","title":"iframe-phone setup"},{"location":"implementing-interactive/#handling-the-initinteractive-message","text":"This is one of the most important messages sent by LARA. It provides most of the information stored by LARA. It tells the interactive what is the current API version, mode ( runtime , authoring or report ), authoredState (state defined by author), interactiveState (state based on student work) and so on. Interactive should add initInteractive handler that reads values stored in data Object / hash: phone.addListener('initInteractive', function (data) { // process data object, e.g.: initializeMode(data.mode); loadAuthoredState(data.authoredState); loadStudentWork(data.interactiveState); });","title":"Handling the initInteractive message"},{"location":"implementing-interactive/#data-passed-to-initinteractive","text":"error - null if everything is okay, error message otherwise (e.g. data fetching might fail). mode - \"authoring\" , \"runtime\" or \"report\" . Interactive can be displayed in one of those three modes, but it's up to interactive whether it supports authoring mode. Runtime is basic mode which is presented to students. Authoring mode can be used by authors to customize interactive. Report mode is used when embedding the interactive in a report. authoredState [optional] - JSON that has been saved by interactive earlier in authoring mode using authoredState message (described below in other section). If it's not defined, it would be falsy value (null or empty string). interactiveState [optional] - JSON that has been saved by interactive earlier in runtime mode using interactiveState message. More detail in Saving Student Progress section . Provided only in runtime mode. If it's not defined, it would be falsy value (null or empty string). globalInteractiveState [optional] - JSON that has been saved by any interactive in the same activity earlier in runtime mode using globalInteractiveState message . Provided only in runtime mode. If it's not defined, it would be falsy value (null or empty string). hasLinkedInteractive [optional] - boolean or undefined. If this is true then the author has linked this interactive to another interactive in the activity or sequence. This will be true even if the linked interactive has not saved state yet. linkedState [optional] - JSON that has been saved by the linked interactive. If no state has been saved this will be falsy. interactiveStateUrl [optional] - Fully qualified URL to access the interactive state externally. See Accessing Interactive State with HTTP for more information. collaboratorUrls [optional] - Fully qualified URL to access the interactive state of each collaborator working with the current student. These URLs can be used to save a copy of the work into each collaborator's interactive state. classInfoUrl - URL to request more information about the class of the student that is running the interactive. When run as a student in the portal this URL is of form: https://learn.staging.concord.org/api/v1/classes/[class_id] it provides information about the teachers and students of the class. As well as a class_hash that can be used to store info about the class in a external system (like Firebase). The URL is protected by cookie based authentication. withCredentials should be used to access it. TODO: what happens when the activity is run without a class? For example when it is run anonymously. interactive - The value of this is {id: [id of interactive in LARA], name: [name of interactive in LARA]} authInfo - The value of this is {provider: [domain of authentication provider], loggedIn: [whether the current user is logged in], email: [email address for the current user]}","title":"Data passed to initInteractive"},{"location":"implementing-interactive/#interactive-customization","text":"If interactive wants to support customization, it should inform LARA about it using supportedFeatures message: phone.post('supportedFeatures', { apiVersion: 1, features: { authoredState: true // + other supported features } }); initInteractive message provides mode property. Interactive can display authoring interface when mode value is equal to \"authoring\" . Every customization made by author should be sent back to LARA using authoredState message: phone.post('authoredState', data); The authoredState data should be a JSON compatible object, that is the only requirement. Next time the interactive is loaded either in authoring or runtime mode, initInteractive will provide this state to the interactive in authoredState property. Note that it's recommended that authoredState should be sent to LARA immediately after every change. LARA provides its own \"Save\" button that would actually save this state to the DB and \"Reset\" which would set it back to null.","title":"Interactive customization"},{"location":"implementing-interactive/#saving-student-progress","text":"If interactive wants to support student progress saving, it should inform LARA about it using supportedFeatures message: phone.post('supportedFeatures', { apiVersion: 1, features: { interactiveState: true // + other supported features } }); Currently, LARA is not paying attention to this interactiveState supportedFeature, but it will do so in the future. When this interactive is added to a LARA page the author needs to check the \"save state\" checkbox. initInteractive provides mode property. \"runtime\" mode means that Interactive is viewed by student. Interactive can save student progress using interactiveState message: phone.post('interactiveState', data); Normally the interactiveState data should be a JSON compatible object, that is the only requirement. Next time the interactive is loaded in runtime mode, initInteractive will provide this state to the interactive in interactiveState property. LARA will send the interactive a getInteractiveState periodically: every 5 seconds on window focus iframe mouseout when the student tries to leave the page containing the interactive The interactive should add a listener for getInteractiveState . To be safe, remember to add the listener before calling phone.initialize(); . Here is an example listener: phone.addListener('getInteractiveState', function () { phone.post('interactiveState', interactiveState); }); IMPORTANT When the student tries to leave the page with the interactive, the interactive needs to respond with an interactiveState message. LARA will not changes pages until it receives this message. There is a special value \"nochange\" , that can be sent as the interactiveState data. This tells LARA the interactiveState has not changed since the last time. This is useful when responding to getInteractiveState","title":"Saving student progress"},{"location":"implementing-interactive/#interactive-aspectratio","text":"If interactive wants to tell LARA what aspect ratio use, it should inform LARA about it using supportedFeatures message: phone.post('supportedFeatures', { apiVersion: 1, features: { aspectRatio: 1.67 // + other supported features } }); The LARA author needs to select \"Default aspect ratio, or set by interactive\" in the interactive authoring dialog box, otherwise this setting will be ignored. More info about the interactive sizing can be found in the LARA Authoring User Manual .","title":"Interactive aspectRatio"},{"location":"implementing-interactive/#custom-learner-url","text":"DEPRECATED This feature is related to student progress saving. Interactive can provide versioned URL to make sure that the given data format is always supported. Otherwise the interactive might be updated and not be able to open the old state format. This is deprecated because it causes more problems than it is worth. We have wanted to remove support for old versions of interactives, and we've had to remember to go through all of the interactive states and these learner urls. Also the concept of saving a URL that works in this maner is confusing. Sometimes the interactive is loaded with the authored URL sometimes it is loaded with the saved URL. So a set of students or testers might see different versions of what seems like it should be the same interactive. Instead of using this approach to handle old state, the interactive should handle migrating its own old state. If migrating its own state isn't practical then please work with the LARA developers to do a batch migration on the server. phone.post('setLearnerUrl', 'https://my.example.interactive/version/1');","title":"Custom learner URL"},{"location":"implementing-interactive/#global-interactive-state","text":"A few interactives can share one global state within a single LARA activity. E.g. you can let students work on the same model on different pages of the activity. Interactive can set global state using interactiveStateGlobal message: phone.post('interactiveStateGlobal', globalState); Once this message is received, the server immediately posts loadInteractiveGlobal to all interactives on the same page (except from the sender of the original save message). So, interactives can listen to this message: phone.addListener('loadInteraciveGlobal', function (globalState) { // Process global state, e.g.: loadState(globalState); }); If one of the interactives has sent interactiveStateGlobal message before another interactive is initialized then the global state will be provided in the initInteractive message. NOTE Another way to communicate between two interactives is with Linked Interactives .","title":"Global interactive state"},{"location":"implementing-interactive/#logging","text":"This message proxies communication from the interactive \u2192 LARA \u2192 Logging server. There is only one way communication between the interactive and LARA. The interactive is expected to post following messages using iframe phone: phone.post('log', {action: 'actionName', data: {someValue: 1, otherValue: 2}}); LARA listens to these events only when logging is enabled (they will be ignored otherwise). When a log message is received, LARA issues a POST request to the Logging server. LARA uses provided action name and data, but also adds additional information to the event (context that might useful for researchers, e.g. user name, activity name, url, session ID, etc.).","title":"Logging"},{"location":"implementing-interactive/#auth-info","text":"Interactive can ask LARA about the current users authentication information using getAuthInfo message. It has no payload data: phone.post('getAuthInfo'); LARA responds using authInfo message: phone.addListener('authInfo', function (info) { // ... }); The payload is the object {provider: <string>, loggedIn: <boolean>, email: <string>} where provider and loggedIn are always set and email is only set if the user has an email address.","title":"Auth info"},{"location":"implementing-interactive/#getextendedsupport","text":"This is a message sent by LARA to the interactive. The interactive can respond with a extendedSupport message. The data of the extendedSupport only supports one property reset . The value of reset should be boolean. If the interactive sends reset: true then LARA will show a button below the interactive for clearing the interactive state and reloading the interactive. If reset: false then LARA will not show this button. By default LARA will show this button. NOTE this extended support message is out of date. It is the only way to hide the reset button, so it isn't deprecated. New options like this will be added to the supportedFeatures message described above.","title":"getExtendedSupport"},{"location":"implementing-interactive/#linked-interactives","text":"Each interactive in LARA can be linked with one other interactive in the same activity or sequence. A LARA author edits the main interactive and can add a reference to the linked interactive. Currently this reference is with an interactive id, but that referencing mechanism could change and it should not effect how the interactives are implemented. When the main interactive is loaded it will be sent the initInteractive message just like normal. This message has 2 fields in related to linked interactives. The hasLinkedInteractive field will be set to true if the author has setup the linking. This will be true even if the learner hasn't done any work on the linked interactive yet. The linkedState field will contain the work the learner has done on the linked interactive. It will be falsy if the student hasn't done any work. An example use case is an activity where a student is incrementally building a diagram. In interactive 1 the student fills out part of the diagram and then in interactive 2 the student is asked to add more to the diagram. Interactive 2 can load in the state from the interactive 1 and display the diagram the student created before. Any new changes made can be saved separately into interactive 2's state. The state of interactive 1 will be preserved. The main interactive can use the hasLinkedInteractive field to tell the difference between being used independently in the activity or being linked to another interactive. In the diagram example above, if interactive 2 sees there is no linkedState, it should then check hasLinkedInteractive . In that case it could tell the student \"you should complete the previous diagram before starting this one\". If hasLinkedInteractive is falsy then the interactive knows it shouldn't show this message.","title":"Linked interactives"},{"location":"implementing-interactive/#accessing-interactive-state-with-http","text":"TODO","title":"Accessing Interactive State with HTTP"},{"location":"interactive-dev-tools/","text":"There is a mock interactive that developers can add to LARA to see how things work: https://concord-consortium.github.io/lara-interactive-api/iframe.html There is a page in which a interactive URL can be added and then the page lets the developer send messages to the interactive: https://concord-consortium.github.io/lara-interactive-api/ These current tools could be much better. Currently it shows a set of buttons for sending specific messages to the interactive. The data sent along with the can be set, and the result can be seen. Not all messages are supported. This doesn't explain how LARA is actually going to communicate with the interactive. A developer would need to look at the documentation to see how to construct the order the messages are being sent, and the data being sent with each message. The set of messages is not complete. There isn't a way to easily reload the interactive after a developer has changed it. If the developer is using live reload this wouldn't be a problem. But not all devs will be doing that. The browser seems to cache the content in an iframe differently. Ideas for improvements: - split the tool into two parts: a generic iframe-phone message sender. This would let the dev send any message to the interactive and then see any responses. Some message names could be provided, but the dev should also be able to type in the messages. A second part would emulate what happens when the interactive is embedded in LARA. See below. - add a reload button so it is easier to reload the interactive, this might take some testing on different browsers. It might not be possible to get the browser to clear the cache. - The LARA tool, would need at least three modes: runtime, authoring, and reporting. And it would also need a authoring UI that would let the dev set the same options an author can set in LARA: saves state, has_report_url, ... Then the dev would need to able to see and change the runtime state, the authoring state, and the linked state. There should be some log of what is happening so when multiple messages go by the dev can see the data of each. And ideally there would be a step, play, pause control. So the dev could step through the series of messages LARA sends to the interactive. In runtime mode there would need to be a button that would simulate the 'next' button in LARA. This button requires a save state interactive to return some state before moving on. And it would also be an indication of the interactive allowing LARA to move on, if the interactive is blocking forward navigation. - it would be useful to have a test iframe that would show the messages lara is sending to it. I'm pretty sure we had this already somewhere...","title":"Interactive dev tools"},{"location":"safari-cookies-redirects/","text":"Safari / IE, cookies and iframe redirects \uf0c1 While recently debugging a weird authentication failure in an app that is regularly embedded within an iframe, I discovered some unexpected behavior in Safari and IE with respect to how it handles cookies for the sites within the iframe. The TL;DR is this: Cookies will not be sent to the destination site of a 302 redirect (the destination defined in the HTTP Location header), regardless of whether or not you've previously visited that site (unless the site is within the same main domain as the redirecting site). In Safari, most of this behavior is due to the recent change of default settings. Under Privacy -> Cookies and website data , the setting changed from Allow from websites I visit to Allow from current website only . There doesn't seem to be a setting around this behavior in IE. Example \uf0c1 Our app uses OAuth2 to sign in via a different app. The sign in process involves several redirects (these aren't the actual domains/paths, but roughly the same steps): Request Response GET: https://app.com/login 302: https://sso.com/sso/login GET: https://sso.com/sso/login 200 POST: https://sso.com/sso/login 302: https://app.com/sso/callback GET: https://app.com/sso/callback 302: https://app.com/ This all works fine in Safari when accessing app.com in a top-level window. However, this all breaks down when running within an iframe. It turns out that Safari will not send cookies to sso.com in the 2nd request, and additionally will not send cookies to app.com in the 4th request. The whole sign in process relies on maintaining consistent sessions, so when no cookies are sent, the sign in doesn't take, and the user is left on app.com in a logged out state. Workarounds \uf0c1 I haven't been able to test this, but supposedly you can work around this cookie behavior by rendering a page which redirects via the page content, rather than redirecting via a 302 response with a Location header. <html> <head> <title>Sign In</title> <meta http-equiv=\"refresh\" content=\"0;URL='https://sso.com/sso/login'\" /> </head> <body> <p>This page has moved to a <a href=\"https://sso.com/sso/login\">new location</a>.</p> </body> </html> However, you'll have to take care that the request to the other site is essentially the same (Referrer, Origin, etc all present the same info). Also, Safari's definition of current website is a bit loose when it comes to the hostname. foo.app.com is considered the same site as bar.app.com. We were fortunate enough to be able to use this tactic to bring our app into the same \"site\" as the sso provider, but that's not usually possible when working with a 3rd-party provider. If your redirecting code makes a full round-trip, another option is to do all of your redirecting in a separate window. Use Javascript to open a window, and then monitor its url. Once the url is back to the location you're expecting, close the window and reload the iframe page. The library is here: // A wrapper around having an external link pop up in its own window, and then automatically monitoring it // and closing it when it returns to the same domain as the current page. window.inIframe = function() { try { return window.self !== window.top; } catch (e) { return true; } }; window.AutomaticallyClosingPopupLink = { configure: function($link, directUrl, popupUrl, afterCloseUrl) { var onClick = function() { if (window.inIframe()) { // Pop up the url in a new window // Monitor it and close it when done // Redirect the current page when closed this._popupWindow($link.id, popupUrl, afterCloseUrl); } else { window.location.href = directUrl; } }.bind(this); $link.on('click', onClick); }, // This code was adapted from CODAP's implementation of a similar feature _popupWindow: function(id, popupUrl, afterCloseUrl) { var width = 800, height = 480, position = this._computeScreenLocation(width, height), windowFeatures = [ 'width=' + width, 'height=' + height, 'top=' + position.top || 200, 'left=' + position.left || 200, 'dependent=yes', 'resizable=no', 'location=no', 'dialog=yes', 'menubar=no' ], exceptionCount = 0, panel = window.open(popupUrl, id, windowFeatures.join()), checkPanelHref = function() { try { /* This is a bit of a hack. Accessing a popup's location throws a security exception * when the url is cross-origin. Therefore, 1) this should only be used with urls that are cross-origin, and 2) the url * should eventually return to a non-cross-origin url at the time the window should be closed. */ var href = panel.location.href; // This will throw an exception if the url is still cross-origin. // If exceptionCount is not 0, then we hit an external url and came back. Assume that we're done. // If it's still 0, then keep waiting for the url to change to something external and change back. if (exceptionCount > 0) { window.clearInterval(timer); panel.close(); if (afterCloseUrl) { document.location = afterCloseUrl; } else { document.location.reload(); } } } catch(e) { exceptionCount++; } }, timer = window.setInterval(checkPanelHref, 200); }, _computeScreenLocation: function(w, h) { // Fixes dual-screen position Most browsers Firefox var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left; var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top; var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width; var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height; var left = ((width / 2) - (w / 2)) + dualScreenLeft; var top = ((height / 2) - (h / 2)) + dualScreenTop; return {left: left, top: top}; } }; And it's used via this code in the page: jQuery(function() { var button = jQuery('#login_button'), path = '/login', popup = '/popupLogin', redirect = '/'; window.AutomaticallyClosingPopupLink.configure(button, path, popup, redirect); });","title":"Safari / IE, cookies and iframe redirects"},{"location":"safari-cookies-redirects/#safari-ie-cookies-and-iframe-redirects","text":"While recently debugging a weird authentication failure in an app that is regularly embedded within an iframe, I discovered some unexpected behavior in Safari and IE with respect to how it handles cookies for the sites within the iframe. The TL;DR is this: Cookies will not be sent to the destination site of a 302 redirect (the destination defined in the HTTP Location header), regardless of whether or not you've previously visited that site (unless the site is within the same main domain as the redirecting site). In Safari, most of this behavior is due to the recent change of default settings. Under Privacy -> Cookies and website data , the setting changed from Allow from websites I visit to Allow from current website only . There doesn't seem to be a setting around this behavior in IE.","title":"Safari / IE, cookies and iframe redirects"},{"location":"safari-cookies-redirects/#example","text":"Our app uses OAuth2 to sign in via a different app. The sign in process involves several redirects (these aren't the actual domains/paths, but roughly the same steps): Request Response GET: https://app.com/login 302: https://sso.com/sso/login GET: https://sso.com/sso/login 200 POST: https://sso.com/sso/login 302: https://app.com/sso/callback GET: https://app.com/sso/callback 302: https://app.com/ This all works fine in Safari when accessing app.com in a top-level window. However, this all breaks down when running within an iframe. It turns out that Safari will not send cookies to sso.com in the 2nd request, and additionally will not send cookies to app.com in the 4th request. The whole sign in process relies on maintaining consistent sessions, so when no cookies are sent, the sign in doesn't take, and the user is left on app.com in a logged out state.","title":"Example"},{"location":"safari-cookies-redirects/#workarounds","text":"I haven't been able to test this, but supposedly you can work around this cookie behavior by rendering a page which redirects via the page content, rather than redirecting via a 302 response with a Location header. <html> <head> <title>Sign In</title> <meta http-equiv=\"refresh\" content=\"0;URL='https://sso.com/sso/login'\" /> </head> <body> <p>This page has moved to a <a href=\"https://sso.com/sso/login\">new location</a>.</p> </body> </html> However, you'll have to take care that the request to the other site is essentially the same (Referrer, Origin, etc all present the same info). Also, Safari's definition of current website is a bit loose when it comes to the hostname. foo.app.com is considered the same site as bar.app.com. We were fortunate enough to be able to use this tactic to bring our app into the same \"site\" as the sso provider, but that's not usually possible when working with a 3rd-party provider. If your redirecting code makes a full round-trip, another option is to do all of your redirecting in a separate window. Use Javascript to open a window, and then monitor its url. Once the url is back to the location you're expecting, close the window and reload the iframe page. The library is here: // A wrapper around having an external link pop up in its own window, and then automatically monitoring it // and closing it when it returns to the same domain as the current page. window.inIframe = function() { try { return window.self !== window.top; } catch (e) { return true; } }; window.AutomaticallyClosingPopupLink = { configure: function($link, directUrl, popupUrl, afterCloseUrl) { var onClick = function() { if (window.inIframe()) { // Pop up the url in a new window // Monitor it and close it when done // Redirect the current page when closed this._popupWindow($link.id, popupUrl, afterCloseUrl); } else { window.location.href = directUrl; } }.bind(this); $link.on('click', onClick); }, // This code was adapted from CODAP's implementation of a similar feature _popupWindow: function(id, popupUrl, afterCloseUrl) { var width = 800, height = 480, position = this._computeScreenLocation(width, height), windowFeatures = [ 'width=' + width, 'height=' + height, 'top=' + position.top || 200, 'left=' + position.left || 200, 'dependent=yes', 'resizable=no', 'location=no', 'dialog=yes', 'menubar=no' ], exceptionCount = 0, panel = window.open(popupUrl, id, windowFeatures.join()), checkPanelHref = function() { try { /* This is a bit of a hack. Accessing a popup's location throws a security exception * when the url is cross-origin. Therefore, 1) this should only be used with urls that are cross-origin, and 2) the url * should eventually return to a non-cross-origin url at the time the window should be closed. */ var href = panel.location.href; // This will throw an exception if the url is still cross-origin. // If exceptionCount is not 0, then we hit an external url and came back. Assume that we're done. // If it's still 0, then keep waiting for the url to change to something external and change back. if (exceptionCount > 0) { window.clearInterval(timer); panel.close(); if (afterCloseUrl) { document.location = afterCloseUrl; } else { document.location.reload(); } } } catch(e) { exceptionCount++; } }, timer = window.setInterval(checkPanelHref, 200); }, _computeScreenLocation: function(w, h) { // Fixes dual-screen position Most browsers Firefox var dualScreenLeft = window.screenLeft !== undefined ? window.screenLeft : screen.left; var dualScreenTop = window.screenTop !== undefined ? window.screenTop : screen.top; var width = window.innerWidth ? window.innerWidth : document.documentElement.clientWidth ? document.documentElement.clientWidth : screen.width; var height = window.innerHeight ? window.innerHeight : document.documentElement.clientHeight ? document.documentElement.clientHeight : screen.height; var left = ((width / 2) - (w / 2)) + dualScreenLeft; var top = ((height / 2) - (h / 2)) + dualScreenTop; return {left: left, top: top}; } }; And it's used via this code in the page: jQuery(function() { var button = jQuery('#login_button'), path = '/login', popup = '/popupLogin', redirect = '/'; window.AutomaticallyClosingPopupLink.configure(button, path, popup, redirect); });","title":"Workarounds"},{"location":"shutterbug/","text":"Shutterbug API \uf0c1 Shutterbug is used widely in Lab and in LARA, it uses postMessage to request child iFrames HTML content for snapshotting. The basic PostMessage API Calls that are used in the shutterbug javascript project are documented in the github repo Shutterbug Messages \uf0c1 htmlFragRequest \uf0c1 Parent asks iframes about their content: var message = { type: 'htmlFragRequest', id: id, // Shutterbug ID iframeReqId: iframeId, // position of iframe in dom iframeReqTimeout: this.iframeReqTimeout * 0.6 }; window.postMessage(JSON.stringify(message), \"*\"); And an Iframe sends its content back: var response = { type: 'htmlFragResponse', value: html, iframeReqId: iframeReqId, // counter, from request id: id // sender_id from request }; source.postMessage(JSON.stringify(response), \"*\");","title":"Shutterbug API"},{"location":"shutterbug/#shutterbug-api","text":"Shutterbug is used widely in Lab and in LARA, it uses postMessage to request child iFrames HTML content for snapshotting. The basic PostMessage API Calls that are used in the shutterbug javascript project are documented in the github repo","title":"Shutterbug API"},{"location":"shutterbug/#shutterbug-messages","text":"","title":"Shutterbug Messages"},{"location":"shutterbug/#htmlfragrequest","text":"Parent asks iframes about their content: var message = { type: 'htmlFragRequest', id: id, // Shutterbug ID iframeReqId: iframeId, // position of iframe in dom iframeReqTimeout: this.iframeReqTimeout * 0.6 }; window.postMessage(JSON.stringify(message), \"*\"); And an Iframe sends its content back: var response = { type: 'htmlFragResponse', value: html, iframeReqId: iframeReqId, // counter, from request id: id // sender_id from request }; source.postMessage(JSON.stringify(response), \"*\");","title":"htmlFragRequest"},{"location":"using-iframe-phone/","text":"Using iFramePhone \uf0c1 As mentioned iFramePhone is the service which LARA uses for much of its iFrame communication. It is also used by Lab Interactives internally. Most of the Lab messages are ignored by LARA. Here for reference is what the implementation looks like. Taken from the iFramePhone Readme : Parent Setup \uf0c1 var phone = new iframePhone.ParentEndpoint(iframeElement, function () { console.log(\"connection with iframe established\"); }); phone.post('testMessage', 'abc'); phone.addListener('response', function (content) { console.log(\"parent received response: \" + content); }); Iframe (child) Setup \uf0c1 var phone = iframePhone.getIFrameEndpoint(); phone.addListener('testMessage', function (content) { console.log(\"iframe received message: \" + content); phone.post('response', 'got it'); }); // IMPORTANT: // Initialize connection after all message listeners are added! phone.initialize(); Hello Messages \uf0c1 iFramePhone uses a hello messages to start communication with a specified origin. These messages get sent using the PostMessage API and look like this: var message = { type: \"hello\", origin: \"https://lab.concord.org\" }; Other Messages \uf0c1 Subsequent messages follow a similar pattern, specifiying type which helps determine which listeners to notify: var message = { type:\"modelLoaded\", \u2026 }; Message Posting Implementation \uf0c1 The post messages looks like this as they are being sent out through iFramePhone. You don't need to worry about this; it is here for reference. message = { type: \"getLearnerUrl\", origin: \"http://localhost:3000\", content: {} // something specific to 'type' }; Window.postMessage(JSON.stringify(message), targetOrigin);","title":"Using iFramePhone"},{"location":"using-iframe-phone/#using-iframephone","text":"As mentioned iFramePhone is the service which LARA uses for much of its iFrame communication. It is also used by Lab Interactives internally. Most of the Lab messages are ignored by LARA. Here for reference is what the implementation looks like. Taken from the iFramePhone Readme :","title":"Using iFramePhone"},{"location":"using-iframe-phone/#parent-setup","text":"var phone = new iframePhone.ParentEndpoint(iframeElement, function () { console.log(\"connection with iframe established\"); }); phone.post('testMessage', 'abc'); phone.addListener('response', function (content) { console.log(\"parent received response: \" + content); });","title":"Parent Setup"},{"location":"using-iframe-phone/#iframe-child-setup","text":"var phone = iframePhone.getIFrameEndpoint(); phone.addListener('testMessage', function (content) { console.log(\"iframe received message: \" + content); phone.post('response', 'got it'); }); // IMPORTANT: // Initialize connection after all message listeners are added! phone.initialize();","title":"Iframe (child) Setup"},{"location":"using-iframe-phone/#hello-messages","text":"iFramePhone uses a hello messages to start communication with a specified origin. These messages get sent using the PostMessage API and look like this: var message = { type: \"hello\", origin: \"https://lab.concord.org\" };","title":"Hello Messages"},{"location":"using-iframe-phone/#other-messages","text":"Subsequent messages follow a similar pattern, specifiying type which helps determine which listeners to notify: var message = { type:\"modelLoaded\", \u2026 };","title":"Other Messages"},{"location":"using-iframe-phone/#message-posting-implementation","text":"The post messages looks like this as they are being sent out through iFramePhone. You don't need to worry about this; it is here for reference. message = { type: \"getLearnerUrl\", origin: \"http://localhost:3000\", content: {} // something specific to 'type' }; Window.postMessage(JSON.stringify(message), targetOrigin);","title":"Message Posting Implementation"}]}